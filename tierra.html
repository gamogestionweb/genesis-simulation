<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>TIERRA - Opus Despierta</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body { background: #0a0a0f; color: #fff; font-family: 'Georgia', serif; }

        .main { display: flex; height: 100vh; }
        .world { width: 60%; height: 100%; position: relative; }
        #canvas { width: 100%; height: 100%; }

        #panel {
            width: 40%;
            height: 100vh;
            background: linear-gradient(180deg, #1a1510 0%, #0d0a08 100%);
            border-left: 2px solid #8b7355;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 10px 15px;
            background: #1a1510;
            border-bottom: 1px solid #3d3020;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-header h2 { color: #d4a574; font-size: 14px; font-weight: normal; }
        .panel-header button {
            background: #2d5016;
            color: #a0d060;
            border: 1px solid #4a8020;
            padding: 5px 12px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 11px;
        }

        #thoughts {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 12px;
            line-height: 1.5;
        }

        .thought {
            padding: 8px 10px;
            margin: 6px 0;
            border-radius: 4px;
            animation: fadeIn 0.4s ease;
        }
        .thought.sensation { background: rgba(139,115,85,0.2); border-left: 3px solid #8b7355; }
        .thought.emotion { background: rgba(180,100,100,0.2); border-left: 3px solid #b46464; }
        .thought.thinking { background: rgba(100,130,180,0.2); border-left: 3px solid #6482b4; }
        .thought.discovery { background: rgba(100,180,100,0.3); border-left: 3px solid #64b464; font-weight: bold; }
        .thought.question { background: rgba(180,150,100,0.2); border-left: 3px solid #b49664; font-style: italic; }
        .thought.theory { background: rgba(150,100,180,0.25); border-left: 3px solid #9664b4; }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        #stats {
            background: #0d0a08;
            padding: 8px;
            border-top: 1px solid #3d3020;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            font-size: 10px;
        }
        .stat { text-align: center; padding: 4px; background: #1a1510; border-radius: 3px; }
        .stat label { color: #666; display: block; font-size: 8px; }
        .stat span { color: #d4a574; font-size: 11px; }

        #controls {
            position: fixed;
            top: 8px;
            left: 8px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        #controls button {
            background: rgba(20,15,10,0.9);
            color: #d4a574;
            border: 1px solid #8b7355;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 10px;
        }

        #hud {
            position: fixed;
            top: 8px;
            left: 50%;
            transform: translateX(-70%);
            background: rgba(10,8,5,0.9);
            padding: 8px 20px;
            border-radius: 5px;
            font-size: 12px;
            color: #d4a574;
            border: 1px solid #3d3020;
        }

        #minimap {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 200px;
            height: 60px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #8b7355;
            border-radius: 3px;
        }

        /* Modal Informe */
        #reportModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            overflow-y: auto;
        }
        #reportContent {
            max-width: 1000px;
            margin: 20px auto;
            padding: 30px;
            background: #12100d;
            border: 2px solid #8b7355;
            border-radius: 10px;
        }
        .report-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #3d3020;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        .report-header h1 { color: #d4a574; font-size: 22px; }
        .report-section {
            background: #1a1715;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 3px solid #8b7355;
        }
        .report-section h3 { color: #d4a574; margin-bottom: 10px; font-size: 14px; }
        .report-section p, .report-section li { color: #a0a0a0; font-size: 12px; line-height: 1.6; }
        .discovery-item { background: #1d2a1d; padding: 8px; margin: 5px 0; border-radius: 4px; border-left: 3px solid #64b464; }
        .theory-item { background: #2a1d2a; padding: 8px; margin: 5px 0; border-radius: 4px; border-left: 3px solid #9664b4; }
        .question-item { background: #2a2a1d; padding: 8px; margin: 5px 0; border-radius: 4px; border-left: 3px solid #b49664; }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="sim.togglePause()">Pausa</button>
        <button onclick="sim.setSpeed(1)">1x</button>
        <button onclick="sim.setSpeed(3)">3x</button>
        <button onclick="sim.setSpeed(10)">10x</button>
        <button onclick="sim.reset()">Reset</button>
    </div>

    <div id="hud">
        <span id="season">Primavera</span> | Día <span id="dayNum">1</span> | <span id="timeOfDay">Amanecer</span> | <span id="weather">Despejado</span>
    </div>

    <div class="main">
        <div class="world">
            <canvas id="canvas"></canvas>
            <canvas id="minimap"></canvas>
        </div>

        <div id="panel">
            <div class="panel-header">
                <h2>CONSCIENCIA DE OPUS</h2>
                <button onclick="sim.generateReport()">GENERAR INFORME</button>
            </div>
            <div id="thoughts"></div>
            <div id="stats">
                <div class="stat"><label>HAMBRE</label><span id="sHunger">0%</span></div>
                <div class="stat"><label>SED</label><span id="sThirst">0%</span></div>
                <div class="stat"><label>FATIGA</label><span id="sFatigue">0%</span></div>
                <div class="stat"><label>TEMP</label><span id="sTemp">37°</span></div>
                <div class="stat"><label>SALUD</label><span id="sHealth">100%</span></div>
                <div class="stat"><label>BIOMA</label><span id="sBiome">--</span></div>
                <div class="stat"><label>ALTITUD</label><span id="sAlt">0m</span></div>
                <div class="stat"><label>DÍAS</label><span id="sDays">1</span></div>
                <div class="stat"><label>DESCUB.</label><span id="sDisc">0</span></div>
                <div class="stat"><label>TEORÍAS</label><span id="sTheory">0</span></div>
            </div>
        </div>
    </div>

    <!-- Modal Informe -->
    <div id="reportModal">
        <div id="reportContent"></div>
    </div>

<script>
// ==================== CONSTANTES DEL MUNDO ====================
const WORLD_WIDTH = 12000;  // 12km de mundo
const WORLD_HEIGHT = 800;
const SEA_LEVEL = 500;

// ==================== MUNDO TIERRA ====================
const World = {
    // Tiempo
    time: 0,
    dayLength: 180,  // 3 minutos por día
    day: 1,
    year: 1,
    season: 0,
    daysPerSeason: 15,

    // Luna
    moonPhase: 0,
    lunarCycle: 30,

    // Clima
    temperature: 20,
    humidity: 50,
    windSpeed: 5,
    windDirection: 1,
    precipitation: 'none', // none, rain, snow, hail
    precipitationIntensity: 0,
    cloudCover: 0.3,
    fog: 0,

    // Fenómenos especiales
    rainbow: false,
    aurora: false,
    eclipse: false,
    meteor: null,
    earthquake: 0,

    // Terreno
    terrain: [],
    biomes: [],

    // Entidades
    trees: [],
    plants: [],
    animals: [],
    clouds: [],
    waterBodies: [],

    // Recursos
    fruits: [],
    deadAnimals: [],

    // Volcanes y geología
    volcanoes: [],
    hotSprings: [],
    caves: [],

    init() {
        this.generateTerrain();
        this.identifyBiomes();
        this.createWaterBodies();
        this.populateFlora();
        this.populateFauna();
        this.createGeology();
        this.initClouds();
        this.initWeather();
    },

    generateTerrain() {
        this.terrain = [];
        let height = SEA_LEVEL;
        let momentum = 0;

        // Semillas para diferentes regiones
        const regions = [
            {start: 0, end: 800, type: 'ocean', baseHeight: SEA_LEVEL + 100},
            {start: 800, end: 1200, type: 'beach', baseHeight: SEA_LEVEL - 20},
            {start: 1200, end: 2500, type: 'coastal_forest', baseHeight: SEA_LEVEL - 80},
            {start: 2500, end: 3500, type: 'plains', baseHeight: SEA_LEVEL - 100},
            {start: 3500, end: 4000, type: 'river_valley', baseHeight: SEA_LEVEL - 50},
            {start: 4000, end: 5500, type: 'dense_forest', baseHeight: SEA_LEVEL - 120},
            {start: 5500, end: 6500, type: 'hills', baseHeight: SEA_LEVEL - 180},
            {start: 6500, end: 7500, type: 'savanna', baseHeight: SEA_LEVEL - 100},
            {start: 7500, end: 8500, type: 'desert', baseHeight: SEA_LEVEL - 80},
            {start: 8500, end: 9500, type: 'badlands', baseHeight: SEA_LEVEL - 150},
            {start: 9500, end: 10500, type: 'mountains', baseHeight: SEA_LEVEL - 350},
            {start: 10500, end: 11200, type: 'alpine', baseHeight: SEA_LEVEL - 450},
            {start: 11200, end: 11800, type: 'glacier', baseHeight: SEA_LEVEL - 400},
            {start: 11800, end: 12000, type: 'tundra', baseHeight: SEA_LEVEL - 200}
        ];

        for(let x = 0; x < WORLD_WIDTH; x++) {
            const region = regions.find(r => x >= r.start && x < r.end);
            const targetHeight = region ? region.baseHeight : SEA_LEVEL - 100;

            // Ruido para variación natural
            const noise1 = Math.sin(x * 0.01) * 30;
            const noise2 = Math.sin(x * 0.03) * 15;
            const noise3 = Math.sin(x * 0.007) * 50;

            momentum += (Math.random() - 0.5) * 2;
            momentum *= 0.95;
            momentum += (targetHeight - height) * 0.01;

            height += momentum;
            height = height * 0.99 + targetHeight * 0.01;

            const finalHeight = height + noise1 + noise2 + noise3;

            this.terrain.push({
                height: Math.max(100, Math.min(WORLD_HEIGHT - 50, finalHeight)),
                type: region ? region.type : 'plains',
                moisture: 50,
                fertility: 50
            });
        }

        // Suavizado
        for(let pass = 0; pass < 5; pass++) {
            const smoothed = [];
            for(let x = 0; x < WORLD_WIDTH; x++) {
                let sum = 0, count = 0;
                for(let dx = -10; dx <= 10; dx++) {
                    const nx = x + dx;
                    if(nx >= 0 && nx < WORLD_WIDTH) {
                        sum += this.terrain[nx].height;
                        count++;
                    }
                }
                smoothed.push({...this.terrain[x], height: sum / count});
            }
            this.terrain = smoothed;
        }
    },

    identifyBiomes() {
        this.biomes = [];
        for(let x = 0; x < WORLD_WIDTH; x++) {
            const t = this.terrain[x];
            const h = t.height;

            let biome;
            if(h > SEA_LEVEL) {
                biome = 'ocean';
            } else if(t.type === 'beach') {
                biome = 'beach';
            } else if(t.type === 'desert' || t.type === 'badlands') {
                biome = h < SEA_LEVEL - 200 ? 'canyon' : 'desert';
            } else if(t.type === 'mountains' || t.type === 'alpine') {
                biome = h < SEA_LEVEL - 400 ? 'peak' : 'mountain';
            } else if(t.type === 'glacier' || t.type === 'tundra') {
                biome = 'tundra';
            } else if(t.type === 'dense_forest' || t.type === 'coastal_forest') {
                biome = 'forest';
            } else if(t.type === 'savanna') {
                biome = 'savanna';
            } else if(t.type === 'river_valley') {
                biome = 'wetland';
            } else if(t.type === 'hills') {
                biome = 'hills';
            } else {
                biome = 'plains';
            }

            this.biomes.push(biome);
        }
    },

    createWaterBodies() {
        this.waterBodies = [];

        // Océano
        this.waterBodies.push({
            type: 'ocean',
            x1: 0, x2: 800,
            depth: 200,
            salinity: 35
        });

        // Río principal
        this.waterBodies.push({
            type: 'river',
            x1: 3600, x2: 3900,
            depth: 30,
            salinity: 0,
            flowDirection: -1
        });

        // Lago de montaña
        this.waterBodies.push({
            type: 'lake',
            x1: 10000, x2: 10300,
            depth: 50,
            salinity: 0
        });

        // Oasis en desierto
        this.waterBodies.push({
            type: 'oasis',
            x1: 8000, x2: 8100,
            depth: 10,
            salinity: 5
        });

        // Actualizar terreno para agua
        for(const wb of this.waterBodies) {
            for(let x = wb.x1; x < wb.x2; x++) {
                if(x >= 0 && x < WORLD_WIDTH) {
                    this.terrain[x].water = true;
                    this.terrain[x].waterType = wb.type;
                    this.terrain[x].waterDepth = wb.depth;
                }
            }
        }
    },

    populateFlora() {
        this.trees = [];
        this.plants = [];

        for(let x = 100; x < WORLD_WIDTH - 100; x += 5) {
            const biome = this.biomes[x];
            const terrain = this.terrain[x];

            if(terrain.water) continue;

            // Árboles según bioma
            let treeChance = 0;
            let treeTypes = [];

            switch(biome) {
                case 'forest':
                    treeChance = 0.4;
                    treeTypes = ['oak', 'pine', 'birch', 'maple'];
                    break;
                case 'plains':
                    treeChance = 0.05;
                    treeTypes = ['oak', 'willow'];
                    break;
                case 'savanna':
                    treeChance = 0.08;
                    treeTypes = ['acacia', 'baobab'];
                    break;
                case 'mountain':
                    treeChance = 0.15;
                    treeTypes = ['pine', 'fir'];
                    break;
                case 'tundra':
                    treeChance = 0.02;
                    treeTypes = ['dwarf_pine'];
                    break;
                case 'wetland':
                    treeChance = 0.2;
                    treeTypes = ['willow', 'cypress'];
                    break;
            }

            if(Math.random() < treeChance && treeTypes.length > 0) {
                const type = treeTypes[Math.floor(Math.random() * treeTypes.length)];
                this.trees.push({
                    x: x + Math.random() * 5,
                    y: terrain.height,
                    type: type,
                    height: 30 + Math.random() * 50,
                    hasFruit: Math.random() < 0.3,
                    fruitCount: Math.floor(Math.random() * 8),
                    age: Math.random() * 100
                });
            }

            // Plantas
            let plantChance = biome === 'desert' ? 0.02 : (biome === 'tundra' ? 0.05 : 0.15);
            if(Math.random() < plantChance) {
                const plantTypes = {
                    'forest': ['fern', 'mushroom', 'berry_bush', 'moss'],
                    'plains': ['grass', 'flower', 'wheat'],
                    'desert': ['cactus', 'tumbleweed'],
                    'savanna': ['tall_grass', 'shrub'],
                    'tundra': ['lichen', 'moss'],
                    'wetland': ['reed', 'lily', 'cattail'],
                    'mountain': ['alpine_flower', 'moss'],
                    'beach': ['dune_grass', 'seaweed']
                };

                const types = plantTypes[biome] || ['grass'];
                this.plants.push({
                    x: x + Math.random() * 5,
                    y: terrain.height,
                    type: types[Math.floor(Math.random() * types.length)],
                    edible: Math.random() < 0.2,
                    poisonous: Math.random() < 0.05
                });
            }
        }
    },

    populateFauna() {
        this.animals = [];

        const animalTemplates = [
            // Herbívoros
            {type: 'rabbit', size: 8, speed: 100, biomes: ['plains', 'forest', 'hills'], behavior: 'timid', diet: 'herbivore'},
            {type: 'deer', size: 25, speed: 140, biomes: ['forest', 'plains', 'hills'], behavior: 'timid', diet: 'herbivore'},
            {type: 'elk', size: 40, speed: 120, biomes: ['forest', 'mountain'], behavior: 'neutral', diet: 'herbivore'},
            {type: 'bison', size: 50, speed: 80, biomes: ['plains', 'savanna'], behavior: 'neutral', diet: 'herbivore'},
            {type: 'goat', size: 20, speed: 90, biomes: ['mountain', 'hills'], behavior: 'neutral', diet: 'herbivore'},

            // Depredadores
            {type: 'wolf', size: 25, speed: 130, biomes: ['forest', 'tundra', 'mountain'], behavior: 'predator', diet: 'carnivore', dangerous: true},
            {type: 'bear', size: 60, speed: 80, biomes: ['forest', 'mountain'], behavior: 'territorial', diet: 'omnivore', dangerous: true},
            {type: 'lion', size: 45, speed: 110, biomes: ['savanna', 'plains'], behavior: 'predator', diet: 'carnivore', dangerous: true},
            {type: 'fox', size: 12, speed: 100, biomes: ['forest', 'plains', 'tundra'], behavior: 'timid', diet: 'omnivore'},

            // Aves
            {type: 'eagle', size: 15, speed: 80, biomes: ['mountain', 'plains'], behavior: 'predator', diet: 'carnivore', flies: true},
            {type: 'crow', size: 8, speed: 60, biomes: ['forest', 'plains', 'wetland'], behavior: 'neutral', diet: 'omnivore', flies: true},
            {type: 'seagull', size: 10, speed: 70, biomes: ['beach', 'ocean'], behavior: 'neutral', diet: 'omnivore', flies: true},

            // Acuáticos
            {type: 'fish', size: 10, speed: 50, biomes: ['ocean', 'wetland'], behavior: 'timid', diet: 'omnivore', aquatic: true},
            {type: 'salmon', size: 15, speed: 60, biomes: ['wetland'], behavior: 'timid', diet: 'omnivore', aquatic: true},
            {type: 'crab', size: 8, speed: 20, biomes: ['beach', 'ocean'], behavior: 'neutral', diet: 'omnivore'},

            // Pequeños
            {type: 'squirrel', size: 6, speed: 80, biomes: ['forest'], behavior: 'timid', diet: 'herbivore'},
            {type: 'mouse', size: 3, speed: 60, biomes: ['plains', 'forest'], behavior: 'timid', diet: 'herbivore'},

            // Reptiles
            {type: 'snake', size: 10, speed: 40, biomes: ['desert', 'savanna', 'forest'], behavior: 'timid', diet: 'carnivore', dangerous: true},
            {type: 'lizard', size: 6, speed: 50, biomes: ['desert', 'savanna'], behavior: 'timid', diet: 'omnivore'},

            // Insectos (enjambres)
            {type: 'butterfly', size: 2, speed: 30, biomes: ['plains', 'forest'], behavior: 'neutral', flies: true},
            {type: 'bee', size: 2, speed: 40, biomes: ['plains', 'forest'], behavior: 'neutral', flies: true}
        ];

        for(const template of animalTemplates) {
            const count = template.size < 10 ? 30 : (template.size < 30 ? 15 : 8);

            for(let i = 0; i < count; i++) {
                let x, biome, attempts = 0;
                do {
                    x = 500 + Math.random() * (WORLD_WIDTH - 1000);
                    biome = this.biomes[Math.floor(x)];
                    attempts++;
                } while(!template.biomes.includes(biome) && attempts < 100);

                if(attempts < 100) {
                    const terrain = this.terrain[Math.floor(x)];
                    this.animals.push({
                        ...template,
                        id: this.animals.length,
                        x: x,
                        y: template.aquatic ? terrain.height + 20 : (template.flies ? terrain.height - 50 - Math.random() * 80 : terrain.height),
                        vx: (Math.random() - 0.5) * 30,
                        vy: 0,
                        health: 100,
                        hunger: 0,
                        state: 'idle',
                        stateTimer: Math.random() * 10,
                        home: x
                    });
                }
            }
        }
    },

    createGeology() {
        // Volcán en las montañas
        this.volcanoes = [{
            x: 10200,
            active: true,
            lastEruption: 0,
            heat: 80
        }];

        // Aguas termales
        this.hotSprings = [
            {x: 10100, temp: 40},
            {x: 9800, temp: 35}
        ];

        // Cuevas
        this.caves = [];
        for(let x = 9000; x < 11500; x += 200 + Math.random() * 300) {
            const terrain = this.terrain[Math.floor(x)];
            if(this.biomes[Math.floor(x)] === 'mountain' || this.biomes[Math.floor(x)] === 'hills') {
                this.caves.push({
                    x: x,
                    y: terrain.height,
                    depth: 20 + Math.random() * 60,
                    hasBats: Math.random() < 0.5,
                    hasBear: Math.random() < 0.2
                });
            }
        }
    },

    initClouds() {
        this.clouds = [];
        for(let i = 0; i < 25; i++) {
            this.clouds.push({
                x: Math.random() * WORLD_WIDTH,
                y: 40 + Math.random() * 100,
                width: 80 + Math.random() * 150,
                height: 30 + Math.random() * 40,
                speed: 8 + Math.random() * 15,
                rain: false
            });
        }
    },

    initWeather() {
        this.weatherTimer = 0;
        this.weatherDuration = 60 + Math.random() * 120;
    },

    update(dt) {
        this.time += dt;

        // Ciclo día/noche
        const dayProgress = (this.time % this.dayLength) / this.dayLength;

        // Nuevo día
        const newDay = Math.floor(this.time / this.dayLength) + 1;
        if(newDay !== this.day) {
            this.day = newDay;
            this.season = Math.floor(((this.day - 1) % (this.daysPerSeason * 4)) / this.daysPerSeason);
            this.year = Math.floor((this.day - 1) / (this.daysPerSeason * 4)) + 1;

            // Fase lunar
            this.moonPhase = (this.day % this.lunarCycle) / this.lunarCycle;
        }

        // Temperatura según hora, estación y bioma
        const hourTemp = Math.sin((dayProgress - 0.25) * Math.PI * 2) * 12;
        const seasonBaseTemp = [15, 30, 18, 0][this.season];
        this.temperature = seasonBaseTemp + hourTemp;

        // Actualizar clima
        this.updateWeather(dt);

        // Fenómenos especiales
        this.updatePhenomena(dt);

        // Nubes
        for(const cloud of this.clouds) {
            cloud.x += cloud.speed * this.windDirection * dt;
            if(cloud.x > WORLD_WIDTH + 200) cloud.x = -200;
            if(cloud.x < -200) cloud.x = WORLD_WIDTH + 200;
        }

        // Animales
        this.updateAnimals(dt);

        // Frutas caen en otoño
        if(this.season === 2 && Math.random() < 0.002 * dt) {
            const tree = this.trees[Math.floor(Math.random() * this.trees.length)];
            if(tree && tree.fruitCount > 0) {
                tree.fruitCount--;
                this.fruits.push({
                    x: tree.x + (Math.random() - 0.5) * 15,
                    y: tree.y,
                    type: 'fruit',
                    nutrition: 25 + Math.random() * 20,
                    age: 0
                });
            }
        }

        // Frutas se pudren
        for(let i = this.fruits.length - 1; i >= 0; i--) {
            this.fruits[i].age += dt;
            if(this.fruits[i].age > 300) {
                this.fruits.splice(i, 1);
            }
        }
    },

    updateWeather(dt) {
        this.weatherTimer += dt;

        if(this.weatherTimer > this.weatherDuration) {
            this.weatherTimer = 0;
            this.weatherDuration = 60 + Math.random() * 180;

            // Cambio de clima
            const roll = Math.random();
            if(roll < 0.5) {
                this.precipitation = 'none';
                this.precipitationIntensity = 0;
            } else if(roll < 0.75) {
                this.precipitation = this.temperature < 2 ? 'snow' : 'rain';
                this.precipitationIntensity = 0.3 + Math.random() * 0.7;
            } else if(roll < 0.9) {
                this.precipitation = this.temperature < 2 ? 'snow' : 'rain';
                this.precipitationIntensity = 0.7 + Math.random() * 0.3;
                // Tormenta
                if(this.precipitation === 'rain' && Math.random() < 0.3) {
                    this.storm = true;
                }
            } else {
                this.precipitation = 'none';
                this.fog = 0.5 + Math.random() * 0.5;
            }
        }

        // Viento
        this.windSpeed += (Math.random() - 0.5) * dt * 5;
        this.windSpeed = Math.max(0, Math.min(30, this.windSpeed));
        if(Math.random() < 0.0005 * dt) this.windDirection *= -1;

        // Nubes
        if(this.precipitation !== 'none') {
            this.cloudCover = Math.min(1, this.cloudCover + dt * 0.1);
        } else {
            this.cloudCover = Math.max(0.1, this.cloudCover - dt * 0.05);
        }

        // Niebla se disipa
        if(this.fog > 0) {
            this.fog = Math.max(0, this.fog - dt * 0.02);
        }

        // Arcoíris después de lluvia
        if(this.precipitation === 'none' && this.humidity > 70 && this.getLightLevel() > 0.6) {
            this.rainbow = Math.random() < 0.01;
        } else {
            this.rainbow = false;
        }

        // Humedad
        if(this.precipitation !== 'none') {
            this.humidity = Math.min(100, this.humidity + dt * 5);
        } else {
            this.humidity = Math.max(20, this.humidity - dt);
        }
    },

    updatePhenomena(dt) {
        // Aurora en latitudes altas (tundra) de noche
        const isNight = this.getLightLevel() < 0.3;
        if(isNight && Math.random() < 0.001) {
            this.aurora = true;
        }
        if(this.aurora && Math.random() < 0.01) {
            this.aurora = false;
        }

        // Meteoros de noche
        if(isNight && Math.random() < 0.005 * dt) {
            this.meteor = {
                x: Math.random() * WORLD_WIDTH,
                y: 50,
                angle: 0.5 + Math.random() * 0.5,
                life: 2
            };
        }
        if(this.meteor) {
            this.meteor.life -= dt;
            if(this.meteor.life <= 0) this.meteor = null;
        }

        // Terremotos ocasionales
        if(Math.random() < 0.0001 * dt) {
            this.earthquake = 0.5 + Math.random() * 0.5;
        }
        if(this.earthquake > 0) {
            this.earthquake = Math.max(0, this.earthquake - dt * 0.3);
        }

        // Erupción volcánica
        for(const v of this.volcanoes) {
            if(v.active && Math.random() < 0.00005 * dt) {
                v.erupting = true;
                v.eruptionTimer = 30 + Math.random() * 60;
            }
            if(v.erupting) {
                v.eruptionTimer -= dt;
                if(v.eruptionTimer <= 0) {
                    v.erupting = false;
                }
            }
        }
    },

    updateAnimals(dt) {
        for(const animal of this.animals) {
            if(animal.health <= 0) continue;

            animal.stateTimer -= dt;
            animal.hunger += dt * 0.1;

            if(animal.hunger > 100) {
                animal.health -= dt * 2;
            }

            if(animal.stateTimer <= 0) {
                // Cambiar estado
                if(animal.hunger > 60) {
                    animal.state = 'foraging';
                } else if(Math.random() < 0.3) {
                    animal.state = 'walking';
                    animal.vx = (Math.random() - 0.5) * animal.speed;
                } else {
                    animal.state = 'idle';
                    animal.vx *= 0.5;
                }
                animal.stateTimer = 3 + Math.random() * 10;
            }

            // Movimiento
            if(animal.state === 'walking' || animal.state === 'foraging' || animal.state === 'fleeing') {
                animal.x += animal.vx * dt;

                // Límites
                animal.x = Math.max(100, Math.min(WORLD_WIDTH - 100, animal.x));

                // Volver a casa gradualmente
                if(Math.abs(animal.x - animal.home) > 500) {
                    animal.vx += (animal.home - animal.x) * 0.01;
                }
            }

            // Altura según terreno
            if(!animal.flies && !animal.aquatic) {
                const tx = Math.floor(Math.max(0, Math.min(WORLD_WIDTH - 1, animal.x)));
                animal.y = this.terrain[tx].height;
            }
        }

        // Eliminar animales muertos
        this.animals = this.animals.filter(a => a.health > 0);
    },

    getTerrainAt(x) {
        const ix = Math.floor(Math.max(0, Math.min(WORLD_WIDTH - 1, x)));
        return this.terrain[ix];
    },

    getBiomeAt(x) {
        const ix = Math.floor(Math.max(0, Math.min(WORLD_WIDTH - 1, x)));
        return this.biomes[ix] || 'plains';
    },

    getWaterAt(x) {
        const terrain = this.getTerrainAt(x);
        return terrain.water ? terrain.waterType : null;
    },

    getLocalTemperature(x, y) {
        let temp = this.temperature;
        const biome = this.getBiomeAt(x);
        const altitude = SEA_LEVEL - y;

        // Altitud reduce temperatura
        temp -= altitude * 0.01;

        // Biomas modifican temperatura
        if(biome === 'desert') temp += 10;
        if(biome === 'tundra' || biome === 'glacier') temp -= 15;
        if(biome === 'forest') temp -= 3;

        // Aguas termales
        for(const hs of this.hotSprings) {
            const dist = Math.abs(x - hs.x);
            if(dist < 50) {
                temp += (50 - dist) / 50 * hs.temp;
            }
        }

        // Volcán
        for(const v of this.volcanoes) {
            const dist = Math.abs(x - v.x);
            if(dist < 200) {
                temp += (200 - dist) / 200 * v.heat * (v.erupting ? 3 : 1);
            }
        }

        return temp;
    },

    getLightLevel() {
        const dayProgress = (this.time % this.dayLength) / this.dayLength;
        let light;

        if(dayProgress < 0.2) light = 0.05 + dayProgress * 2;
        else if(dayProgress < 0.3) light = 0.45 + (dayProgress - 0.2) * 5.5;
        else if(dayProgress < 0.7) light = 1.0;
        else if(dayProgress < 0.8) light = 1.0 - (dayProgress - 0.7) * 5.5;
        else light = 0.45 - (dayProgress - 0.8) * 2;

        // Nubes reducen luz
        light *= (1 - this.cloudCover * 0.4);

        // Niebla reduce luz
        light *= (1 - this.fog * 0.3);

        return Math.max(0.02, light);
    },

    getTimeOfDay() {
        const p = (this.time % this.dayLength) / this.dayLength;
        if(p < 0.2) return 'Noche';
        if(p < 0.25) return 'Alba';
        if(p < 0.3) return 'Amanecer';
        if(p < 0.5) return 'Mañana';
        if(p < 0.7) return 'Tarde';
        if(p < 0.75) return 'Atardecer';
        if(p < 0.8) return 'Crepúsculo';
        return 'Noche';
    },

    getSeasonName() {
        return ['Primavera', 'Verano', 'Otoño', 'Invierno'][this.season];
    },

    getWeatherDescription() {
        if(this.storm) return 'Tormenta';
        if(this.fog > 0.3) return 'Niebla';
        if(this.precipitation === 'rain') return this.precipitationIntensity > 0.6 ? 'Lluvia fuerte' : 'Lluvia';
        if(this.precipitation === 'snow') return this.precipitationIntensity > 0.6 ? 'Nevada' : 'Nieve';
        if(this.cloudCover > 0.7) return 'Nublado';
        if(this.cloudCover > 0.4) return 'Parcialmente nublado';
        return 'Despejado';
    }
};

// ==================== SER HUMANO ====================
const Being = {
    x: 2000,
    y: 400,
    vx: 0,
    vy: 0,

    // Necesidades
    hunger: 0,
    thirst: 0,
    fatigue: 0,
    health: 100,
    bodyTemp: 37,

    // Estado
    grounded: false,
    inWater: false,
    waterType: null,
    currentBiome: 'plains',

    // Historial de posiciones
    visited: new Set(),

    actionCooldown: 0,

    update(dt) {
        // Gravedad
        if(!this.grounded && !this.inWater) {
            this.vy += 500 * dt;
        }

        // Agua
        const terrain = World.getTerrainAt(this.x);
        const waterType = World.getWaterAt(this.x);
        this.inWater = waterType && this.y > terrain.height - 30;
        this.waterType = waterType;

        if(this.inWater) {
            this.vy *= 0.92;
            this.vx *= 0.95;
            this.vy -= 120 * dt;

            // En océano profundo es peligroso
            if(waterType === 'ocean' && this.y > terrain.height + 50) {
                this.fatigue += dt * 3;
            }
        }

        // Fricción
        if(this.grounded) {
            const biome = World.getBiomeAt(this.x);
            let friction = 0.88;
            if(biome === 'beach') friction = 0.8;
            if(biome === 'tundra' && World.season === 3) friction = 0.95; // Hielo
            this.vx *= friction;
        } else {
            this.vx *= 0.995;
        }

        // Viento
        if(!this.grounded) {
            this.vx += World.windSpeed * World.windDirection * 0.5 * dt;
        }

        // Movimiento
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Colisión con terreno
        const groundY = terrain.height - 35;
        if(this.y >= groundY && !terrain.water) {
            this.y = groundY;
            if(Math.abs(this.vy) > 300) {
                // Daño por caída
                this.health -= (Math.abs(this.vy) - 300) * 0.05;
            }
            this.vy = 0;
            this.grounded = true;
        } else if(!terrain.water) {
            this.grounded = false;
        }

        // Límites
        this.x = Math.max(50, Math.min(WORLD_WIDTH - 50, this.x));

        // Bioma actual
        this.currentBiome = World.getBiomeAt(this.x);

        // Registrar lugares visitados
        this.visited.add(Math.floor(this.x / 100));

        // Necesidades
        const activity = Math.abs(this.vx) > 10 ? 1.5 : 1;
        this.hunger += dt * 0.12 * activity;
        this.thirst += dt * 0.18 * activity;

        // Temperatura afecta sed
        const localTemp = World.getLocalTemperature(this.x, this.y);
        if(localTemp > 30) this.thirst += dt * 0.15;
        if(localTemp < 5) this.hunger += dt * 0.1;

        // Fatiga
        if(Math.abs(this.vx) > 50) {
            this.fatigue += dt * 0.3;
        } else if(this.grounded && Math.abs(this.vx) < 5) {
            this.fatigue = Math.max(0, this.fatigue - dt * 0.2);
        }

        // Temperatura corporal
        let targetTemp = 37;
        if(localTemp < 10) targetTemp = 37 - (10 - localTemp) * 0.15;
        if(localTemp > 35) targetTemp = 37 + (localTemp - 35) * 0.1;
        if(this.inWater) targetTemp = Math.min(targetTemp, 35);

        this.bodyTemp += (targetTemp - this.bodyTemp) * dt * 0.1;

        // Efectos de necesidades
        if(this.hunger > 85) this.health -= dt * 0.5;
        if(this.thirst > 85) this.health -= dt * 1;
        if(this.bodyTemp < 34) this.health -= dt * 0.8;
        if(this.bodyTemp > 40) this.health -= dt * 0.5;
        if(this.fatigue > 95) this.health -= dt * 0.3;

        // Límites
        this.hunger = Math.max(0, Math.min(100, this.hunger));
        this.thirst = Math.max(0, Math.min(100, this.thirst));
        this.fatigue = Math.max(0, Math.min(100, this.fatigue));
        this.health = Math.max(0, Math.min(100, this.health));
        this.bodyTemp = Math.max(30, Math.min(42, this.bodyTemp));

        if(this.actionCooldown > 0) this.actionCooldown -= dt;
    },

    act(action) {
        if(this.actionCooldown > 0) return false;

        switch(action) {
            case 'left':
                this.vx -= this.inWater ? 40 : 100;
                this.vx = Math.max(-200, this.vx);
                this.fatigue += 0.5;
                this.actionCooldown = 0.05;
                return true;

            case 'right':
                this.vx += this.inWater ? 40 : 100;
                this.vx = Math.min(200, this.vx);
                this.fatigue += 0.5;
                this.actionCooldown = 0.05;
                return true;

            case 'jump':
                if(this.grounded && this.fatigue < 90) {
                    this.vy = -350;
                    this.grounded = false;
                    this.fatigue += 5;
                    this.actionCooldown = 0.4;
                    return true;
                }
                return false;

            case 'swim_up':
                if(this.inWater) {
                    this.vy -= 150;
                    this.fatigue += 2;
                    return true;
                }
                return false;

            case 'rest':
                this.fatigue = Math.max(0, this.fatigue - 1);
                return true;

            case 'drink':
                if(this.inWater || this.nearWater()) {
                    this.thirst = Math.max(0, this.thirst - 50);
                    this.actionCooldown = 1;
                    return true;
                }
                return false;

            case 'eat':
                const food = this.findFood();
                if(food) {
                    this.hunger = Math.max(0, this.hunger - food.nutrition);
                    if(food.poisonous) this.health -= 30;
                    World.fruits = World.fruits.filter(f => f !== food);
                    this.actionCooldown = 1.5;
                    return true;
                }
                return false;
        }
        return false;
    },

    nearWater() {
        for(let dx = -50; dx <= 50; dx += 10) {
            if(World.getWaterAt(this.x + dx)) return true;
        }
        return false;
    },

    findFood() {
        for(const f of World.fruits) {
            if(Math.abs(f.x - this.x) < 40 && Math.abs(f.y - this.y) < 50) {
                return f;
            }
        }
        for(const p of World.plants) {
            if(p.edible && Math.abs(p.x - this.x) < 30 && Math.abs(p.y - this.y) < 40) {
                return {nutrition: 15, poisonous: p.poisonous};
            }
        }
        return null;
    },

    sense() {
        const nearbyAnimals = World.animals.filter(a => {
            const dist = Math.sqrt((a.x - this.x) ** 2 + (a.y - this.y) ** 2);
            return dist < 250 && a.health > 0;
        }).map(a => ({
            type: a.type,
            distance: Math.sqrt((a.x - this.x) ** 2 + (a.y - this.y) ** 2),
            direction: a.x > this.x ? 'derecha' : 'izquierda',
            dangerous: a.dangerous || false,
            size: a.size
        }));

        const nearbyFood = World.fruits.filter(f => {
            const dist = Math.sqrt((f.x - this.x) ** 2 + (f.y - this.y) ** 2);
            return dist < 100;
        }).length;

        const localTemp = World.getLocalTemperature(this.x, this.y);

        // Detectar fenómenos
        const phenomena = [];
        if(World.rainbow) phenomena.push('arcoíris');
        if(World.aurora) phenomena.push('luces en el cielo');
        if(World.meteor) phenomena.push('estrella fugaz');
        if(World.earthquake > 0.3) phenomena.push('temblor');
        for(const v of World.volcanoes) {
            if(v.erupting && Math.abs(v.x - this.x) < 2000) {
                phenomena.push('montaña que escupe fuego');
            }
        }

        return {
            // Posición
            x: this.x,
            y: this.y,
            altitude: Math.max(0, SEA_LEVEL - this.y),
            vx: this.vx,
            vy: this.vy,
            grounded: this.grounded,
            inWater: this.inWater,
            waterType: this.waterType,

            // Necesidades
            hunger: this.hunger,
            thirst: this.thirst,
            fatigue: this.fatigue,
            health: this.health,
            bodyTemp: this.bodyTemp,

            // Entorno
            biome: this.currentBiome,
            temperature: localTemp,
            humidity: World.humidity,
            windSpeed: World.windSpeed,
            precipitation: World.precipitation,
            precipitationIntensity: World.precipitationIntensity,
            fog: World.fog,
            lightLevel: World.getLightLevel(),

            // Tiempo
            timeOfDay: World.getTimeOfDay(),
            season: World.getSeasonName(),
            day: World.day,
            year: World.year,
            moonPhase: World.moonPhase,

            // Percepciones
            nearbyAnimals: nearbyAnimals,
            nearbyFood: nearbyFood,
            canDrink: this.inWater || this.nearWater(),
            canEat: this.findFood() !== null,
            phenomena: phenomena,

            // Estadísticas
            placesVisited: this.visited.size,
            weather: World.getWeatherDescription()
        };
    },

    reset() {
        this.x = 2000;
        this.y = 400;
        this.vx = 0;
        this.vy = 0;
        this.hunger = 0;
        this.thirst = 0;
        this.fatigue = 0;
        this.health = 100;
        this.bodyTemp = 37;
        this.visited = new Set();
    }
};

// ==================== MENTE ====================
const Mind = {
    thoughts: [],
    discoveries: [],
    theories: [],
    questions: [],
    thoughtCount: 0,
    lastThinkTime: 0,
    thinkInterval: 4,
    isThinking: false,
    pendingAction: 'rest',

    think(text, type = 'thinking') {
        this.thoughtCount++;
        this.thoughts.push({text, type, id: this.thoughtCount, day: World.day});
        if(this.thoughts.length > 100) this.thoughts.shift();
    },

    async callAPI(sensorData) {
        if(this.isThinking) return;
        this.isThinking = true;

        try {
            const response = await fetch('/think', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(sensorData)
            });

            if(!response.ok) throw new Error('Error');

            const data = await response.json();

            if(data.thought) {
                this.think(data.thought, data.type || 'thinking');
            }

            if(data.discovery) {
                if(!this.discoveries.includes(data.discovery)) {
                    this.discoveries.push(data.discovery);
                    this.think('DESCUBRIMIENTO: ' + data.discovery, 'discovery');
                }
            }

            if(data.theory) {
                if(!this.theories.includes(data.theory)) {
                    this.theories.push(data.theory);
                    this.think('TEORÍA: ' + data.theory, 'theory');
                }
            }

            if(data.question) {
                if(!this.questions.includes(data.question)) {
                    this.questions.push(data.question);
                    this.think(data.question, 'question');
                }
            }

            this.pendingAction = data.action || 'rest';

        } catch(err) {
            console.error(err);
            this.pendingAction = ['rest', 'left', 'right'][Math.floor(Math.random() * 3)];
        }

        this.isThinking = false;
    },

    process(sensorData) {
        if(World.time - this.lastThinkTime >= this.thinkInterval && !this.isThinking) {
            this.lastThinkTime = World.time;
            this.callAPI(sensorData);
        }
        return this.pendingAction;
    },

    reset() {
        this.thoughts = [];
        this.discoveries = [];
        this.theories = [];
        this.questions = [];
        this.thoughtCount = 0;
        this.pendingAction = 'rest';
        fetch('/reset', {method: 'POST'}).catch(() => {});
    }
};

// ==================== SIMULACIÓN ====================
const sim = {
    canvas: null,
    ctx: null,
    minimap: null,
    minimapCtx: null,
    paused: false,
    speed: 1,
    lastTime: 0,
    cameraX: 0,
    lastThoughtCount: 0,

    init() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.minimap = document.getElementById('minimap');
        this.minimapCtx = this.minimap.getContext('2d');

        this.resize();
        window.onresize = () => this.resize();

        World.init();

        requestAnimationFrame(t => this.loop(t));
        setInterval(() => this.updateUI(), 100);
    },

    resize() {
        const container = this.canvas.parentElement;
        this.canvas.width = container.clientWidth;
        this.canvas.height = container.clientHeight;
        this.minimap.width = 200;
        this.minimap.height = 60;
    },

    loop(time) {
        if(!this.lastTime) this.lastTime = time;
        let dt = Math.min((time - this.lastTime) / 1000, 0.05) * this.speed;
        this.lastTime = time;

        if(!this.paused) {
            World.update(dt);
            Being.update(dt);

            const sensorData = Being.sense();
            const action = Mind.process(sensorData);
            Being.act(action);
        }

        // Cámara
        const targetX = Being.x - this.canvas.width / 2;
        this.cameraX += (targetX - this.cameraX) * 0.08;
        this.cameraX = Math.max(0, Math.min(WORLD_WIDTH - this.canvas.width, this.cameraX));

        this.render();
        this.renderMinimap();

        requestAnimationFrame(t => this.loop(t));
    },

    render() {
        const c = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;

        const light = World.getLightLevel();

        // Cielo
        const skyGrad = c.createLinearGradient(0, 0, 0, h * 0.6);
        if(light > 0.6) {
            skyGrad.addColorStop(0, `rgb(${80 + light*60}, ${130 + light*50}, ${180 + light*40})`);
            skyGrad.addColorStop(1, `rgb(${160 + light*40}, ${190 + light*30}, ${210 + light*30})`);
        } else if(light > 0.3) {
            skyGrad.addColorStop(0, `rgb(${120 + light*100}, ${80 + light*80}, ${60 + light*80})`);
            skyGrad.addColorStop(1, `rgb(${180 + light*40}, ${120 + light*60}, ${80 + light*80})`);
        } else {
            skyGrad.addColorStop(0, `rgb(${5 + light*40}, ${8 + light*40}, ${25 + light*50})`);
            skyGrad.addColorStop(1, `rgb(${15 + light*50}, ${20 + light*50}, ${40 + light*60})`);
        }
        c.fillStyle = skyGrad;
        c.fillRect(0, 0, w, h);

        // Estrellas
        if(light < 0.3) {
            c.fillStyle = '#fff';
            for(let i = 0; i < 150; i++) {
                c.globalAlpha = (0.3 - light) * 2 * (0.4 + Math.sin(World.time * 2 + i) * 0.3);
                c.beginPath();
                c.arc((i * 97 + this.cameraX * 0.05) % w, (i * 61) % (h * 0.5), Math.random() < 0.1 ? 2 : 1, 0, Math.PI * 2);
                c.fill();
            }
            c.globalAlpha = 1;
        }

        // Luna
        if(light < 0.4) {
            const moonX = w * 0.8;
            const moonY = h * 0.12;
            c.fillStyle = `rgba(240, 240, 250, ${(0.4 - light) * 2})`;
            c.beginPath();
            c.arc(moonX, moonY, 20, 0, Math.PI * 2);
            c.fill();
        }

        // Sol
        if(light > 0.4) {
            const dayProgress = (World.time % World.dayLength) / World.dayLength;
            const sunAngle = (dayProgress - 0.25) * Math.PI;
            const sunX = w * 0.5 + Math.cos(sunAngle) * w * 0.4;
            const sunY = h * 0.4 - Math.sin(sunAngle) * h * 0.35;

            if(sunY < h * 0.7 && sunY > 0) {
                const sunGrad = c.createRadialGradient(sunX, sunY, 0, sunX, sunY, 50);
                sunGrad.addColorStop(0, 'rgba(255, 255, 220, 1)');
                sunGrad.addColorStop(0.3, 'rgba(255, 220, 150, 0.6)');
                sunGrad.addColorStop(1, 'rgba(255, 180, 100, 0)');
                c.fillStyle = sunGrad;
                c.beginPath();
                c.arc(sunX, sunY, 50, 0, Math.PI * 2);
                c.fill();
            }
        }

        // Aurora
        if(World.aurora && Being.currentBiome === 'tundra') {
            c.globalAlpha = 0.3;
            for(let i = 0; i < 5; i++) {
                const grad = c.createLinearGradient(0, 50 + i * 20, 0, 100 + i * 20);
                grad.addColorStop(0, 'transparent');
                grad.addColorStop(0.5, `hsl(${120 + Math.sin(World.time + i) * 30}, 80%, 50%)`);
                grad.addColorStop(1, 'transparent');
                c.fillStyle = grad;
                c.fillRect(0, 50 + i * 20, w, 50);
            }
            c.globalAlpha = 1;
        }

        // Nubes
        for(const cloud of World.clouds) {
            const cx = cloud.x - this.cameraX * 0.3;
            if(cx > -200 && cx < w + 200) {
                c.fillStyle = `rgba(255, 255, 255, ${0.4 + World.cloudCover * 0.4})`;
                c.beginPath();
                c.ellipse(cx, cloud.y, cloud.width / 2, cloud.height / 2, 0, 0, Math.PI * 2);
                c.ellipse(cx - cloud.width * 0.3, cloud.y + 8, cloud.width * 0.35, cloud.height * 0.4, 0, 0, Math.PI * 2);
                c.ellipse(cx + cloud.width * 0.25, cloud.y + 5, cloud.width * 0.3, cloud.height * 0.35, 0, 0, Math.PI * 2);
                c.fill();
            }
        }

        // Arcoíris
        if(World.rainbow) {
            c.globalAlpha = 0.4;
            const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3'];
            for(let i = 0; i < colors.length; i++) {
                c.strokeStyle = colors[i];
                c.lineWidth = 8;
                c.beginPath();
                c.arc(w * 0.5, h * 0.9, 300 - i * 10, Math.PI, 0);
                c.stroke();
            }
            c.globalAlpha = 1;
        }

        // Terreno
        const startX = Math.max(0, Math.floor(this.cameraX) - 10);
        const endX = Math.min(WORLD_WIDTH, Math.ceil(this.cameraX + w) + 10);

        // Agua de fondo
        c.fillStyle = 'rgba(20, 60, 120, 0.9)';
        for(let x = startX; x < endX; x++) {
            const t = World.terrain[x];
            if(t.water) {
                const sx = x - this.cameraX;
                const waterY = h - (WORLD_HEIGHT - t.height);
                c.fillRect(sx, waterY, 1, h - waterY);
            }
        }

        // Montañas de fondo
        c.fillStyle = 'rgba(60, 70, 80, 0.3)';
        c.beginPath();
        c.moveTo(0, h);
        for(let x = 0; x < w; x += 20) {
            const worldX = (x + this.cameraX * 0.2) % WORLD_WIDTH;
            const t = World.terrain[Math.floor(worldX)] || {height: 400};
            c.lineTo(x, h - (WORLD_HEIGHT - t.height) * 0.5 - 50);
        }
        c.lineTo(w, h);
        c.fill();

        // Terreno principal
        for(let x = startX; x < endX; x++) {
            const t = World.terrain[x];
            const biome = World.biomes[x];
            const sx = x - this.cameraX;
            const groundY = h - (WORLD_HEIGHT - t.height);

            if(!t.water) {
                let color;
                switch(biome) {
                    case 'ocean': color = '#1a4a6e'; break;
                    case 'beach': color = '#e8d4a8'; break;
                    case 'forest': color = '#3a6830'; break;
                    case 'plains': color = '#5a8c3a'; break;
                    case 'savanna': color = '#a8963a'; break;
                    case 'desert': color = '#c4a86a'; break;
                    case 'canyon': color = '#8b5a3a'; break;
                    case 'hills': color = '#6a8a4a'; break;
                    case 'mountain': color = '#6a6a6a'; break;
                    case 'peak': color = '#8a8a8a'; break;
                    case 'tundra': color = World.season === 3 ? '#e8e8f0' : '#7a8a7a'; break;
                    case 'wetland': color = '#4a6a4a'; break;
                    default: color = '#5a7a4a';
                }

                // Nieve en invierno en altitudes altas
                if(World.season === 3 && t.height < SEA_LEVEL - 200) {
                    color = '#e8e8f0';
                }

                c.fillStyle = color;
                c.fillRect(sx, groundY, 2, h - groundY);
            }
        }

        // Árboles
        for(const tree of World.trees) {
            const tx = tree.x - this.cameraX;
            if(tx > -60 && tx < w + 60) {
                const groundY = h - (WORLD_HEIGHT - tree.y);

                // Tronco
                c.fillStyle = '#4a3020';
                c.fillRect(tx - 4, groundY - tree.height * 0.5, 8, tree.height * 0.5);

                // Copa
                let leafColor;
                if(World.season === 2) leafColor = '#8b5a10'; // Otoño
                else if(World.season === 3 && tree.type !== 'pine') leafColor = '#5a4a3a'; // Invierno
                else leafColor = tree.type === 'pine' ? '#2a4a2a' : '#3a6a30';

                c.fillStyle = leafColor;

                if(tree.type === 'pine' || tree.type === 'fir') {
                    c.beginPath();
                    c.moveTo(tx, groundY - tree.height);
                    c.lineTo(tx - 20, groundY - tree.height * 0.3);
                    c.lineTo(tx + 20, groundY - tree.height * 0.3);
                    c.fill();
                } else {
                    c.beginPath();
                    c.arc(tx, groundY - tree.height * 0.65, 18 + tree.height * 0.2, 0, Math.PI * 2);
                    c.fill();
                }
            }
        }

        // Animales
        for(const animal of World.animals) {
            const ax = animal.x - this.cameraX;
            if(ax > -40 && ax < w + 40 && animal.health > 0) {
                const groundY = h - (WORLD_HEIGHT - animal.y);

                const colors = {
                    'rabbit': '#a08070', 'deer': '#8b6914', 'elk': '#6a5a40',
                    'bison': '#4a3a2a', 'goat': '#808080', 'wolf': '#505050',
                    'bear': '#3a2a1a', 'lion': '#c4a050', 'fox': '#c06020',
                    'eagle': '#4a3020', 'crow': '#1a1a1a', 'seagull': '#e0e0e0',
                    'fish': '#6090b0', 'salmon': '#c07060', 'crab': '#c05030',
                    'squirrel': '#805030', 'mouse': '#908070',
                    'snake': '#506030', 'lizard': '#708050',
                    'butterfly': '#e080c0', 'bee': '#e0c020'
                };

                c.fillStyle = colors[animal.type] || '#808080';

                if(animal.flies) {
                    c.beginPath();
                    c.ellipse(ax, groundY, animal.size / 2, animal.size / 3, 0, 0, Math.PI * 2);
                    c.fill();
                } else if(animal.aquatic) {
                    c.beginPath();
                    c.ellipse(ax, groundY, animal.size / 2, animal.size / 4, 0, 0, Math.PI * 2);
                    c.fill();
                } else {
                    c.fillRect(ax - animal.size / 2, groundY - animal.size, animal.size, animal.size * 0.8);
                }
            }
        }

        // Frutas
        for(const fruit of World.fruits) {
            const fx = fruit.x - this.cameraX;
            if(fx > -10 && fx < w + 10) {
                const groundY = h - (WORLD_HEIGHT - fruit.y);
                c.fillStyle = fruit.age > 200 ? '#6a4020' : '#c03020';
                c.beginPath();
                c.arc(fx, groundY - 5, 5, 0, Math.PI * 2);
                c.fill();
            }
        }

        // Precipitación
        if(World.precipitation !== 'none') {
            const intensity = World.precipitationIntensity;
            if(World.precipitation === 'rain') {
                c.strokeStyle = `rgba(150, 180, 220, ${intensity * 0.5})`;
                c.lineWidth = 1;
                for(let i = 0; i < 150 * intensity; i++) {
                    const rx = (i * 47 + World.time * 400) % w;
                    const ry = (i * 73 + World.time * 800) % h;
                    c.beginPath();
                    c.moveTo(rx, ry);
                    c.lineTo(rx - 2, ry + 20);
                    c.stroke();
                }
            } else if(World.precipitation === 'snow') {
                c.fillStyle = `rgba(255, 255, 255, ${intensity * 0.7})`;
                for(let i = 0; i < 100 * intensity; i++) {
                    const sx = (i * 37 + World.time * 50 + Math.sin(World.time + i) * 20) % w;
                    const sy = (i * 53 + World.time * 100) % h;
                    c.beginPath();
                    c.arc(sx, sy, 2 + Math.random(), 0, Math.PI * 2);
                    c.fill();
                }
            }
        }

        // Niebla
        if(World.fog > 0.1) {
            c.fillStyle = `rgba(200, 210, 220, ${World.fog * 0.6})`;
            c.fillRect(0, h * 0.4, w, h * 0.6);
        }

        // Terremoto
        if(World.earthquake > 0.1) {
            c.save();
            c.translate(Math.sin(World.time * 50) * World.earthquake * 10, Math.cos(World.time * 60) * World.earthquake * 5);
        }

        // El ser
        const bx = Being.x - this.cameraX;
        const by = h - (WORLD_HEIGHT - Being.y) - 35;

        // Sombra
        c.fillStyle = 'rgba(0,0,0,0.25)';
        c.beginPath();
        c.ellipse(bx, by + 38, 12, 4, 0, 0, Math.PI * 2);
        c.fill();

        // Cuerpo
        c.fillStyle = Being.health < 30 ? '#a07060' : '#c9a882';
        c.fillRect(bx - 8, by, 16, 35);

        // Cabeza
        c.beginPath();
        c.arc(bx, by - 8, 10, 0, Math.PI * 2);
        c.fill();

        // Indicador de estado
        if(Being.hunger > 70 || Being.thirst > 70 || Being.health < 40) {
            c.strokeStyle = 'rgba(255, 80, 80, 0.6)';
            c.lineWidth = 2;
            c.beginPath();
            c.arc(bx, by + 15, 25, 0, Math.PI * 2);
            c.stroke();
        }

        // Pensando
        if(Mind.isThinking) {
            c.fillStyle = 'rgba(255, 255, 255, 0.9)';
            c.beginPath();
            c.arc(bx + 18, by - 20, 6, 0, Math.PI * 2);
            c.arc(bx + 26, by - 28, 4, 0, Math.PI * 2);
            c.arc(bx + 32, by - 34, 3, 0, Math.PI * 2);
            c.fill();
        }

        if(World.earthquake > 0.1) c.restore();
    },

    renderMinimap() {
        const c = this.minimapCtx;
        const w = 200, h = 60;

        c.fillStyle = '#1a1510';
        c.fillRect(0, 0, w, h);

        const step = Math.ceil(WORLD_WIDTH / w);
        for(let i = 0; i < w; i++) {
            const x = i * step;
            const t = World.terrain[Math.min(x, WORLD_WIDTH - 1)];
            const biome = World.biomes[Math.min(x, WORLD_WIDTH - 1)];

            let color;
            if(t.water) color = '#2a5a8a';
            else if(biome === 'forest') color = '#3a6a2a';
            else if(biome === 'desert') color = '#a89070';
            else if(biome === 'mountain' || biome === 'peak') color = '#6a6a6a';
            else if(biome === 'tundra') color = '#9aaaaa';
            else color = '#5a7a3a';

            const groundY = h - (h * (WORLD_HEIGHT - t.height) / WORLD_HEIGHT);
            c.fillStyle = color;
            c.fillRect(i, groundY, 1, h - groundY);
        }

        // Posición del ser
        const bx = (Being.x / WORLD_WIDTH) * w;
        c.fillStyle = '#ff6b6b';
        c.fillRect(bx - 1, 0, 3, h);

        // Vista actual
        const viewStart = (this.cameraX / WORLD_WIDTH) * w;
        const viewWidth = (this.canvas.width / WORLD_WIDTH) * w;
        c.strokeStyle = '#8b7355';
        c.strokeRect(viewStart, 0, viewWidth, h);
    },

    updateUI() {
        document.getElementById('sHunger').textContent = Being.hunger.toFixed(0) + '%';
        document.getElementById('sThirst').textContent = Being.thirst.toFixed(0) + '%';
        document.getElementById('sFatigue').textContent = Being.fatigue.toFixed(0) + '%';
        document.getElementById('sTemp').textContent = Being.bodyTemp.toFixed(1) + '°';
        document.getElementById('sHealth').textContent = Being.health.toFixed(0) + '%';
        document.getElementById('sBiome').textContent = Being.currentBiome;
        document.getElementById('sAlt').textContent = Math.max(0, SEA_LEVEL - Being.y).toFixed(0) + 'm';
        document.getElementById('sDays').textContent = World.day;
        document.getElementById('sDisc').textContent = Mind.discoveries.length;
        document.getElementById('sTheory').textContent = Mind.theories.length;

        document.getElementById('season').textContent = World.getSeasonName();
        document.getElementById('dayNum').textContent = World.day;
        document.getElementById('timeOfDay').textContent = World.getTimeOfDay();
        document.getElementById('weather').textContent = World.getWeatherDescription();

        // Pensamientos
        if(Mind.thoughtCount !== this.lastThoughtCount) {
            const container = document.getElementById('thoughts');
            const newThoughts = Mind.thoughts.slice(this.lastThoughtCount - Mind.thoughtCount);

            for(const t of newThoughts) {
                const div = document.createElement('div');
                div.className = 'thought ' + t.type;
                div.innerHTML = `<small style="color:#666">[Día ${t.day}]</small> ${t.text}`;
                container.appendChild(div);
            }

            container.scrollTop = container.scrollHeight;
            while(container.children.length > 80) container.removeChild(container.firstChild);

            this.lastThoughtCount = Mind.thoughtCount;
        }
    },

    togglePause() { this.paused = !this.paused; },
    setSpeed(s) { this.speed = s; },

    reset() {
        World.time = 0;
        World.day = 1;
        World.year = 1;
        World.season = 0;
        World.init();
        Being.reset();
        Mind.reset();
        document.getElementById('thoughts').innerHTML = '';
        this.lastThoughtCount = 0;
    },

    generateReport() {
        const days = World.day;
        const discoveries = Mind.discoveries;
        const theories = Mind.theories;
        const questions = Mind.questions;
        const thoughts = Mind.thoughts;
        const visited = Being.visited.size;

        let html = `
        <div class="report-header">
            <h1>INFORME DE CONSCIENCIA</h1>
            <button onclick="document.getElementById('reportModal').style.display='none'" style="background:#8b5030;color:#fff;border:none;padding:8px 15px;cursor:pointer;border-radius:5px;">Cerrar</button>
        </div>

        <div class="report-section">
            <h3>RESUMEN DE EXISTENCIA</h3>
            <p><strong>Días vividos:</strong> ${days}</p>
            <p><strong>Año:</strong> ${World.year}</p>
            <p><strong>Estación actual:</strong> ${World.getSeasonName()}</p>
            <p><strong>Lugares explorados:</strong> ${visited} zonas (de ~${Math.floor(WORLD_WIDTH/100)} posibles)</p>
            <p><strong>Exploración:</strong> ${((visited / (WORLD_WIDTH/100)) * 100).toFixed(1)}% del mundo</p>
            <p><strong>Bioma actual:</strong> ${Being.currentBiome}</p>
            <p><strong>Estado de salud:</strong> ${Being.health.toFixed(0)}%</p>
        </div>

        <div class="report-section">
            <h3>DESCUBRIMIENTOS (${discoveries.length})</h3>
            ${discoveries.length === 0 ? '<p>Aún no se han registrado descubrimientos formales.</p>' :
              discoveries.map(d => `<div class="discovery-item">${d}</div>`).join('')}
        </div>

        <div class="report-section">
            <h3>TEORÍAS FORMULADAS (${theories.length})</h3>
            ${theories.length === 0 ? '<p>Aún no se han formulado teorías.</p>' :
              theories.map(t => `<div class="theory-item">${t}</div>`).join('')}
        </div>

        <div class="report-section">
            <h3>PREGUNTAS EXISTENCIALES (${questions.length})</h3>
            ${questions.length === 0 ? '<p>Aún no se han registrado preguntas profundas.</p>' :
              questions.map(q => `<div class="question-item">${q}</div>`).join('')}
        </div>

        <div class="report-section">
            <h3>FLUJO DE PENSAMIENTOS (últimos 40)</h3>
            <div style="max-height:400px;overflow-y:auto;">
                ${thoughts.slice(-40).map(t => `
                    <div style="padding:6px 10px;margin:5px 0;border-radius:4px;background:${
                        t.type === 'discovery' ? 'rgba(100,180,100,0.2)' :
                        t.type === 'theory' ? 'rgba(150,100,180,0.2)' :
                        t.type === 'question' ? 'rgba(180,150,100,0.2)' :
                        t.type === 'emotion' ? 'rgba(180,100,100,0.2)' :
                        'rgba(100,130,180,0.15)'
                    };border-left:3px solid ${
                        t.type === 'discovery' ? '#64b464' :
                        t.type === 'theory' ? '#9664b4' :
                        t.type === 'question' ? '#b49664' :
                        t.type === 'emotion' ? '#b46464' :
                        '#6482b4'
                    };">
                        <small style="color:#666">[Día ${t.day}]</small> ${t.text}
                    </div>
                `).join('')}
            </div>
        </div>

        <div class="report-section">
            <h3>ESTADÍSTICAS DEL MUNDO</h3>
            <p><strong>Animales en el mundo:</strong> ${World.animals.length}</p>
            <p><strong>Árboles:</strong> ${World.trees.length}</p>
            <p><strong>Temperatura actual:</strong> ${World.temperature.toFixed(1)}°C</p>
            <p><strong>Clima:</strong> ${World.getWeatherDescription()}</p>
            <p><strong>Humedad:</strong> ${World.humidity.toFixed(0)}%</p>
            <p><strong>Viento:</strong> ${World.windSpeed.toFixed(1)} m/s</p>
        </div>

        <div class="report-section">
            <h3>NOTA SOBRE ESTA CONSCIENCIA</h3>
            <p style="color:#a0a0a0;font-style:italic;">
                Este ser ha experimentado ${days} ciclos de luz y oscuridad en un mundo que desconoce por completo.
                Cada descubrimiento, teoría y pregunta ha emergido de su propia experiencia y razonamiento,
                sin conocimiento previo sobre las leyes que gobiernan este lugar.
            </p>
            <p style="color:#a0a0a0;font-style:italic;">
                Motor: Claude Opus 4.5
            </p>
        </div>
        `;

        document.getElementById('reportContent').innerHTML = html;
        document.getElementById('reportModal').style.display = 'block';
    }
};

window.onload = () => sim.init();
</script>
</body>
</html>
