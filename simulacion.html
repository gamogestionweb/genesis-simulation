<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Consciencia IA</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body { background: #0a0a0f; color: #fff; font-family: Consolas, monospace; }

        .main { display: flex; height: 100vh; max-height: 100vh; }

        /* Canvas - 65% */
        .world { width: 65%; height: 100%; }
        #canvas { width: 100%; height: 100%; background: #111; }

        /* Panel derecho - 35% compacto */
        #panel {
            width: 35%;
            height: 100vh;
            background: #0a0a12;
            border-left: 2px solid #9b59b6;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #panel h2 {
            color: #9b59b6;
            padding: 8px 12px;
            font-size: 13px;
            background: #12121a;
            border-bottom: 1px solid #333;
            flex-shrink: 0;
        }

        #thoughts {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            font-size: 11px;
            line-height: 1.4;
            min-height: 0;
        }

        .t {
            padding: 6px 8px;
            margin: 4px 0;
            border-radius: 4px;
            opacity: 0;
            animation: slideIn 0.3s ease forwards;
        }
        .t.perception { background: rgba(52,152,219,0.25); border-left: 3px solid #3498db; }
        .t.hypothesis { background: rgba(155,89,182,0.25); border-left: 3px solid #9b59b6; }
        .t.discovery { background: rgba(46,204,113,0.4); border-left: 3px solid #2ecc71; font-weight: bold; }
        .t.meta { background: rgba(255,215,0,0.3); border-left: 3px solid #ffd700; font-style: italic; }
        .t.confusion { background: rgba(231,76,60,0.25); border-left: 3px solid #e74c3c; }
        .t.action { background: rgba(241,196,15,0.2); border-left: 3px solid #f1c40f; }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-5px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Panel inferior compacto */
        #bottom {
            display: flex;
            border-top: 1px solid #333;
            flex-shrink: 0;
            height: 100px;
        }

        #laws {
            flex: 1;
            background: #0a0a10;
            padding: 6px;
            overflow-y: auto;
        }
        #laws h3 { color: #27ae60; font-size: 10px; margin-bottom: 4px; }
        .law {
            background: rgba(39,174,96,0.2);
            padding: 4px 6px;
            margin: 2px 0;
            border-radius: 3px;
            font-size: 9px;
            border-left: 2px solid #27ae60;
        }
        .law b { color: #2ecc71; }

        #sensors {
            width: 140px;
            background: #0d0d15;
            padding: 4px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 3px;
            flex-shrink: 0;
        }
        .sensor { background: #1a1a2e; padding: 3px; border-radius: 3px; text-align: center; }
        .sensor h3 { font-size: 7px; color: #666; }
        .sensor span { font-size: 9px; font-weight: bold; color: #aaa; }

        /* Controles */
        #ctrl { position: fixed; top: 5px; left: 5px; z-index: 100; display: flex; gap: 5px; }
        button { background: #2c3e50; color: #fff; border: none; padding: 5px 10px; cursor: pointer; border-radius: 3px; font-size: 10px; }
        button:hover { background: #34495e; }
        #info { position: fixed; top: 5px; left: 220px; display: flex; gap: 8px; font-size: 11px; }
        .box { background: rgba(0,0,0,0.8); padding: 4px 10px; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="ctrl">
        <button onclick="sim.pause()">Pausar</button>
        <button onclick="sim.reset()">Reiniciar</button>
        <button onclick="sim.fast()">Acelerar</button>
        <button onclick="sim.generateReport()" style="background:#27ae60;">INFORME</button>
    </div>

    <!-- Modal del informe -->
    <div id="reportModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:1000; overflow-y:auto;">
        <div style="max-width:950px; margin:20px auto; padding:30px; background:#0d0d15; border:2px solid #27ae60; border-radius:10px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; border-bottom:1px solid #333; padding-bottom:15px;">
                <h1 style="color:#27ae60; margin:0; font-size:20px;">INFORME CIENTÍFICO - LEYES DEL UNIVERSO OBSERVADO</h1>
                <button onclick="document.getElementById('reportModal').style.display='none'" style="background:#e74c3c;">✕ Cerrar</button>
            </div>
            <div id="reportContent" style="font-size:12px; line-height:1.7;"></div>
        </div>
    </div>

    <div id="info">
        <div class="box">Velocidad: <span id="spd">1</span>x</div>
        <div class="box">Tiempo: <span id="time">0</span>s</div>
    </div>

    <div class="main">
        <div class="world">
            <canvas id="canvas"></canvas>
        </div>

        <div id="panel">
            <h2>PENSAMIENTOS DE LA IA</h2>
            <div id="thoughts"></div>
            <div id="bottom">
                <div id="laws">
                    <h3>LEYES DESCUBIERTAS</h3>
                    <div id="lawlist"><em style="color:#444">La IA aun no ha descubierto leyes...</em></div>
                </div>
                <div id="sensors">
                    <div class="sensor"><h3>LUZ</h3><span id="s1">--</span></div>
                    <div class="sensor"><h3>TEMP</h3><span id="s2">--</span></div>
                    <div class="sensor"><h3>VIENTO</h3><span id="s3">--</span></div>
                    <div class="sensor"><h3>SUELO</h3><span id="s4">--</span></div>
                    <div class="sensor"><h3>ENERGIA</h3><span id="s5">--</span></div>
                    <div class="sensor"><h3>VELOCIDAD</h3><span id="s6">--</span></div>
                    <div class="sensor"><h3>ALTURA</h3><span id="s7">--</span></div>
                    <div class="sensor"><h3>PERIODO</h3><span id="s8">--</span></div>
                </div>
            </div>
        </div>
    </div>

<script>
// ==================== FISICA RICA ====================
const Physics = {
    G: 9.81, time: 0, dayLen: 100, wind: 0, temp: 20, light: 1,
    leaves: [], balls: [], platforms: [], water: null,

    init() {
        // Hojas
        for(let i=0; i<20; i++) this.leaves.push({x:Math.random()*800,y:Math.random()*300,vx:0,vy:0,r:Math.random()*6.28,s:3+Math.random()*4});

        // Plataformas elevadas con diferentes propiedades
        this.platforms = [
            {x:80, y:380, w:100, h:12, type:'wood'},
            {x:550, y:320, w:90, h:12, type:'stone'},
            {x:350, y:220, w:70, h:12, type:'ice'},
            {x:700, y:400, w:70, h:12, type:'wood'},
            {x:450, y:150, w:60, h:12, type:'bounce'},  // TRAMPOLIN!
            {x:200, y:300, w:50, h:12, type:'sticky'},  // PEGAJOSO
            {x:600, y:230, w:55, h:12, type:'crumble'}  // SE ROMPE
        ];

        // Agua
        this.water = {x:20, y:420, w:120, h:80};

        // Zona de fuego/calor extremo
        this.fireZone = {x:680, y:430, w:100, h:70};

        // Zona de hielo/frio extremo
        this.iceZone = {x:300, y:440, w:80, h:60};

        // Gravedad invertida temporal
        this.antiGravZone = {x:400, y:100, w:100, h:150, active: true};

        // Teletransporte (portales)
        this.portals = [
            {x:780, y:420, target:{x:50, y:150}, color:'#e74c3c'},
            {x:20, y:150, target:{x:750, y:380}, color:'#3498db'}
        ];

        // Plataformas moviles
        this.movingPlatform = {x:250, y:350, w:60, h:10, dir:1, speed:50, type:'moving'};

        // Particulas visuales
        this.particles = [];

        // Bolas
        this.spawnBall();

        // ===== FENOMENOS OCULTOS (invisibles para humanos) =====

        // Campo de energia invisible que pulsa
        this.energyField = {
            x: 500, y: 300, radius: 80,
            frequency: 0.5, // Hz
            phase: 0,
            strength: 0 // varia con el tiempo
        };

        // Lineas de fuerza invisibles (como campo magnetico)
        this.forceLines = [];
        for(let i = 0; i < 5; i++) {
            this.forceLines.push({
                x1: 100 + i * 150, y1: 100,
                x2: 150 + i * 120, y2: 450,
                strength: 0.3 + Math.random() * 0.4,
                direction: i % 2 === 0 ? 1 : -1
            });
        }

        // Resonancia temporal - zonas donde el tiempo fluye diferente
        this.timeZones = [
            {x: 150, y: 200, r: 60, factor: 0.5},  // Tiempo lento
            {x: 650, y: 250, r: 50, factor: 2.0}   // Tiempo rapido
        ];

        // Memoria del espacio - el espacio "recuerda" donde estuvo el agente
        this.spatialMemory = [];
        this.memoryDecay = 0.995;

        // Energia oscura - fuerza repulsiva entre ciertos puntos
        this.darkEnergyNodes = [
            {x: 200, y: 350},
            {x: 600, y: 150},
            {x: 400, y: 400}
        ];

        // Numeros primos afectan la fisica (patron oculto)
        this.primeEffect = 0;
        this.lastPrimeCheck = 0;

        // Correlacion cuantica - dos puntos conectados
        this.entangledPoints = [
            {x: 100, y: 300, partner: 1},
            {x: 700, y: 200, partner: 0}
        ];
        this.entanglementState = 0;

        // Patron fibonacci en el movimiento
        this.fibSequence = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
        this.fibIndex = 0;
        this.fibTimer = 0;
    },

    spawnBall() {
        if(this.balls.length < 5) {
            this.balls.push({
                x: 100 + Math.random()*600,
                y: -20,
                vx: (Math.random()-0.5)*50,
                vy: 0,
                r: 8 + Math.random()*8,
                color: ['#e74c3c','#3498db','#f1c40f','#9b59b6','#1abc9c'][Math.floor(Math.random()*5)],
                bounces: 0
            });
        }
    },

    update(dt) {
        this.time += dt;

        // Dia/noche mas rapido
        const d = (this.time % this.dayLen) / this.dayLen;
        if(d<0.25){this.light=0.1+(d/0.25)*0.4;this.temp=8+d*24;}
        else if(d<0.5){this.light=0.5+((d-0.25)/0.25)*0.5;this.temp=14+(d-0.25)*44;}
        else if(d<0.75){this.light=1-((d-0.5)/0.25)*0.3;this.temp=25-(d-0.5)*16;}
        else{this.light=0.7-((d-0.75)/0.25)*0.6;this.temp=21-(d-0.75)*52;}

        // Viento variable
        this.wind = 3 + Math.sin(this.time*0.15)*4 + Math.sin(this.time*0.31)*2;

        // Plataforma movil
        this.movingPlatform.x += this.movingPlatform.dir * this.movingPlatform.speed * dt;
        if(this.movingPlatform.x < 200) { this.movingPlatform.dir = 1; }
        if(this.movingPlatform.x > 350) { this.movingPlatform.dir = -1; }

        // Plataforma que se rompe - regenerar
        const crumble = this.platforms.find(p => p.type === 'crumble');
        if(crumble && crumble.broken && this.time - crumble.brokenTime > 8) {
            crumble.broken = false;
        }

        // Particulas de fuego
        if(Math.random() < 0.3) {
            this.particles.push({
                x: this.fireZone.x + Math.random()*this.fireZone.w,
                y: this.fireZone.y + this.fireZone.h,
                vx: (Math.random()-0.5)*20,
                vy: -30 - Math.random()*40,
                life: 1,
                type: 'fire'
            });
        }

        // Particulas de hielo
        if(Math.random() < 0.15) {
            this.particles.push({
                x: this.iceZone.x + Math.random()*this.iceZone.w,
                y: this.iceZone.y + Math.random()*20,
                vx: (Math.random()-0.5)*10,
                vy: -5 - Math.random()*10,
                life: 1,
                type: 'ice'
            });
        }

        // Actualizar particulas
        for(let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx * dt;
            p.y -= p.vy * dt;
            p.life -= dt * 1.5;
            if(p.life <= 0) this.particles.splice(i, 1);
        }

        // ===== ACTUALIZAR FENOMENOS OCULTOS =====

        // Campo de energia pulsante
        this.energyField.phase += dt * this.energyField.frequency * Math.PI * 2;
        this.energyField.strength = Math.sin(this.energyField.phase) * 0.5 + 0.5;

        // Efecto de numeros primos
        const timeInt = Math.floor(this.time);
        if(timeInt !== this.lastPrimeCheck) {
            this.lastPrimeCheck = timeInt;
            this.primeEffect = this.isPrime(timeInt) ? 1.5 : 1.0;
        }

        // Fibonacci timer
        this.fibTimer += dt;
        if(this.fibTimer > this.fibSequence[this.fibIndex] * 0.1) {
            this.fibTimer = 0;
            this.fibIndex = (this.fibIndex + 1) % this.fibSequence.length;
        }

        // Entrelazamiento cuantico oscila
        this.entanglementState = Math.sin(this.time * 1.7) * 0.5 + 0.5;

        // Decaer memoria espacial
        for(let i = this.spatialMemory.length - 1; i >= 0; i--) {
            this.spatialMemory[i].strength *= this.memoryDecay;
            if(this.spatialMemory[i].strength < 0.01) {
                this.spatialMemory.splice(i, 1);
            }
        }

        // Hojas
        for(const l of this.leaves) {
            l.vx += this.wind*0.3*dt + (Math.random()-0.5)*2*dt;
            l.vy += 1.5*dt;
            l.vx *= 0.98; l.vy *= 0.98;
            l.x += l.vx; l.y += l.vy;
            l.r += l.vx*0.05*dt;
            if(l.y > 480) { l.y = 480; l.vy = -l.vy*0.2; }
            if(l.x > 820) l.x = -20;
            if(l.x < -20) l.x = 820;
        }

        // Bolas fisicas
        for(let i = this.balls.length-1; i >= 0; i--) {
            const b = this.balls[i];
            b.vy += this.G*dt*40;
            b.vx += this.wind*0.2*dt;
            b.vx *= 0.995;
            b.x += b.vx*dt;
            b.y += b.vy*dt;

            // Colision suelo
            if(b.y > 480-b.r) {
                b.y = 480-b.r;
                b.vy = -b.vy*0.6;
                b.vx *= 0.8;
                b.bounces++;
            }

            // Colision plataformas
            for(const p of this.platforms) {
                if(b.x+b.r > p.x && b.x-b.r < p.x+p.w && b.y+b.r > p.y && b.y-b.r < p.y+p.h) {
                    if(b.vy > 0) { b.y = p.y - b.r; b.vy = -b.vy * (p.type==='ice'?0.8:0.5); }
                }
            }

            // Agua - frena mucho
            if(b.x > this.water.x && b.x < this.water.x+this.water.w && b.y > this.water.y) {
                b.vx *= 0.95; b.vy *= 0.9;
                b.vy -= 2*dt; // flotabilidad
            }

            // Bordes
            if(b.x < b.r) { b.x = b.r; b.vx = -b.vx*0.5; }
            if(b.x > 800-b.r) { b.x = 800-b.r; b.vx = -b.vx*0.5; }

            // Eliminar si muy quieta
            if(b.bounces > 10 && Math.abs(b.vy) < 5) this.balls.splice(i,1);
        }

        // Spawn nuevas bolas
        if(Math.random() < 0.005) this.spawnBall();
    },

    apply(agent, dt) {
        const prevVy = agent.vy;
        const inWater = agent.x > this.water.x && agent.x < this.water.x+this.water.w && agent.y > this.water.y-20;

        // Gravedad (menor en agua)
        if(!agent.ground) agent.vy += this.G*dt*(inWater ? 15 : 50);

        // Flotabilidad en agua
        if(inWater) {
            agent.vy -= 8*dt;
            agent.vx *= 0.92;
            agent.vy *= 0.92;
        }

        // Viento (menos en agua)
        if(!agent.ground && !inWater) agent.vx += this.wind*0.4*dt;

        // Friccion segun superficie
        if(agent.ground) {
            let friction = 0.6;
            if(agent.surface === 'ice') friction = 0.05;
            else if(agent.surface === 'stone') friction = 0.8;
            agent.vx *= (1 - friction*dt*5);
        }

        agent.x += agent.vx*dt;
        agent.y += agent.vy*dt;

        // Colision suelo
        if(agent.y >= 460) {
            agent.y = 460;
            if(prevVy > 50) agent.impact = prevVy*0.7;
            if(Math.abs(agent.vy) > 10) agent.vy = -agent.vy*0.25;
            else { agent.vy = 0; agent.ground = true; agent.surface = 'ground'; }
        } else {
            agent.ground = false;
            agent.surface = null;
        }

        // Colision plataformas
        for(const p of this.platforms) {
            if(agent.x+15 > p.x && agent.x-15 < p.x+p.w) {
                if(agent.y+20 > p.y && agent.y+20 < p.y+p.h+10 && agent.vy > 0) {
                    agent.y = p.y - 20;
                    if(prevVy > 50) agent.impact = prevVy*0.5;
                    agent.vy = 0;
                    agent.ground = true;
                    agent.surface = p.type;
                }
            }
        }

        // Bordes
        if(agent.x < 20) { agent.x = 20; agent.vx = -agent.vx*0.3; agent.wallHit = true; }
        else if(agent.x > 780) { agent.x = 780; agent.vx = -agent.vx*0.3; agent.wallHit = true; }
        else agent.wallHit = false;

        // Colision con bolas
        for(const b of this.balls) {
            const dx = agent.x - b.x, dy = agent.y - b.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < 20 + b.r) {
                agent.ballHit = {color: b.color, force: Math.sqrt(b.vx*b.vx+b.vy*b.vy)};
                // Empujar agente
                agent.vx += b.vx*0.3;
                agent.vy += b.vy*0.2;
                // Empujar bola
                b.vx -= dx*0.5;
                b.vy -= dy*0.3;
            }
        }

        agent.inWater = inWater;
        agent.windFelt = this.wind;
        agent.lightLevel = this.light;
        agent.temperature = this.temp + (inWater ? -8 : 0);

        // Zona de fuego
        const inFire = agent.x > this.fireZone.x && agent.x < this.fireZone.x + this.fireZone.w &&
                       agent.y > this.fireZone.y - 30 && agent.y < this.fireZone.y + this.fireZone.h;
        if(inFire) {
            agent.temperature = 65 + Math.random()*10;
            agent.energy -= dt * 8; // Pierde energia rapido
            agent.inFire = true;
            // Empujar hacia arriba por el calor
            if(!agent.ground) agent.vy -= 15 * dt;
        } else {
            agent.inFire = false;
        }

        // Zona de hielo extremo
        const inIceZone = agent.x > this.iceZone.x && agent.x < this.iceZone.x + this.iceZone.w &&
                          agent.y > this.iceZone.y - 30 && agent.y < this.iceZone.y + this.iceZone.h;
        if(inIceZone) {
            agent.temperature = -15 + Math.random()*5;
            agent.vx *= 0.998; // Movimiento mas lento por frio
            agent.inIceZone = true;
        } else {
            agent.inIceZone = false;
        }

        // Zona antigravedad
        const inAntiGrav = agent.x > this.antiGravZone.x && agent.x < this.antiGravZone.x + this.antiGravZone.w &&
                           agent.y > this.antiGravZone.y && agent.y < this.antiGravZone.y + this.antiGravZone.h;
        if(inAntiGrav && this.antiGravZone.active) {
            agent.vy -= this.G * dt * 100; // Gravedad invertida fuerte
            agent.inAntiGrav = true;
        } else {
            agent.inAntiGrav = false;
        }

        // Portales
        for(const portal of this.portals) {
            const dist = Math.sqrt((agent.x - portal.x)**2 + (agent.y - portal.y)**2);
            if(dist < 25 && !agent.justTeleported) {
                agent.x = portal.target.x;
                agent.y = portal.target.y;
                agent.vx *= 0.5;
                agent.vy *= 0.5;
                agent.justTeleported = true;
                agent.teleportedFrom = {x: portal.x, y: portal.y};
                setTimeout(() => agent.justTeleported = false, 500);
            }
        }

        // Plataforma movil
        const mp = this.movingPlatform;
        if(agent.x + 15 > mp.x && agent.x - 15 < mp.x + mp.w) {
            if(agent.y + 20 > mp.y && agent.y + 20 < mp.y + mp.h + 10 && agent.vy > 0) {
                agent.y = mp.y - 20;
                agent.vy = 0;
                agent.ground = true;
                agent.surface = 'moving';
                agent.vx += mp.dir * mp.speed * 0.8; // Arrastrar con la plataforma
                agent.onMovingPlatform = true;
            }
        } else {
            agent.onMovingPlatform = false;
        }

        // Plataformas especiales (bounce, sticky, crumble)
        for(const p of this.platforms) {
            if(agent.x + 15 > p.x && agent.x - 15 < p.x + p.w) {
                if(agent.y + 20 > p.y && agent.y + 20 < p.y + p.h + 10 && agent.vy > 0) {
                    if(p.type === 'bounce') {
                        agent.vy = -450; // Super rebote!
                        agent.bounced = true;
                    } else if(p.type === 'sticky') {
                        agent.vx *= 0.3;
                        agent.vy = 0;
                        agent.ground = true;
                        agent.surface = 'sticky';
                        agent.onSticky = true;
                    } else if(p.type === 'crumble' && !p.broken) {
                        agent.y = p.y - 20;
                        agent.vy = 0;
                        agent.ground = true;
                        agent.surface = 'crumble';
                        // Romper despues de un momento
                        if(!p.crumbleTimer) {
                            p.crumbleTimer = setTimeout(() => {
                                p.broken = true;
                                p.brokenTime = this.time;
                                p.crumbleTimer = null;
                            }, 800);
                        }
                    }
                }
            }
        }
    },

    sky() {
        const d = (this.time%this.dayLen)/this.dayLen;
        if(d<0.2||d>0.85) return {r:15,g:15,b:45};
        if(d<0.3) { const t=(d-0.2)/0.1; return {r:15+t*240,g:15+t*140,b:45+t*90}; }
        if(d<0.7) return {r:135,g:200,b:240};
        const t=(d-0.7)/0.15; return {r:255-t*90,g:150-t*70,b:130-t*50};
    },

    sun() {
        const d=(this.time%this.dayLen)/this.dayLen, a=(d-0.25)*Math.PI;
        return {x:400+Math.cos(a)*350, y:380-Math.sin(a)*320, v:d>0.2&&d<0.8};
    },

    isPrime(n) {
        if(n < 2) return false;
        for(let i = 2; i <= Math.sqrt(n); i++) {
            if(n % i === 0) return false;
        }
        return true;
    },

    // Aplicar fenomenos ocultos al agente
    applyHiddenPhysics(agent, dt) {
        // Guardar posicion en memoria espacial
        if(Math.random() < 0.1) {
            this.spatialMemory.push({x: agent.x, y: agent.y, strength: 1});
            if(this.spatialMemory.length > 50) this.spatialMemory.shift();
        }

        // Campo de energia pulsante
        const distToField = Math.sqrt((agent.x - this.energyField.x)**2 + (agent.y - this.energyField.y)**2);
        if(distToField < this.energyField.radius) {
            const force = this.energyField.strength * (1 - distToField / this.energyField.radius) * 30;
            agent.energy += force * dt * 0.5;
            agent.hiddenEnergyEffect = this.energyField.strength;
        } else {
            agent.hiddenEnergyEffect = 0;
        }

        // Lineas de fuerza invisibles
        agent.forceLineEffect = 0;
        for(const line of this.forceLines) {
            const midX = (line.x1 + line.x2) / 2;
            const midY = (line.y1 + line.y2) / 2;
            const dist = Math.sqrt((agent.x - midX)**2 + (agent.y - midY)**2);
            if(dist < 60) {
                agent.vx += line.direction * line.strength * 20 * dt;
                agent.forceLineEffect += line.strength;
            }
        }

        // Zonas temporales
        agent.timeDistortion = 1;
        for(const zone of this.timeZones) {
            const dist = Math.sqrt((agent.x - zone.x)**2 + (agent.y - zone.y)**2);
            if(dist < zone.r) {
                agent.timeDistortion = zone.factor;
                // Afecta velocidad percibida
                if(zone.factor < 1) {
                    agent.vx *= 0.98;
                    agent.vy *= 0.98;
                } else {
                    agent.energy -= dt * 2; // Gastar mas energia en tiempo rapido
                }
            }
        }

        // Memoria espacial - atraido por donde estuvo antes
        agent.spatialMemoryEffect = 0;
        for(const mem of this.spatialMemory) {
            const dist = Math.sqrt((agent.x - mem.x)**2 + (agent.y - mem.y)**2);
            if(dist > 30 && dist < 150) {
                const force = mem.strength * 5 / dist;
                agent.vx += (mem.x - agent.x) / dist * force * dt;
                agent.vy += (mem.y - agent.y) / dist * force * dt;
                agent.spatialMemoryEffect += mem.strength;
            }
        }

        // Energia oscura - repulsion
        agent.darkEnergyEffect = 0;
        for(const node of this.darkEnergyNodes) {
            const dist = Math.sqrt((agent.x - node.x)**2 + (agent.y - node.y)**2);
            if(dist < 100 && dist > 10) {
                const force = 800 / (dist * dist);
                agent.vx += (agent.x - node.x) / dist * force * dt;
                agent.vy += (agent.y - node.y) / dist * force * dt;
                agent.darkEnergyEffect += force;
            }
        }

        // Efecto de numeros primos - gravedad modificada
        agent.primeTimeEffect = this.primeEffect;

        // Efecto Fibonacci - pulsos de fuerza
        agent.fibonacciEffect = this.fibSequence[this.fibIndex];
        if(this.fibTimer < 0.1) {
            agent.vy -= this.fibSequence[this.fibIndex] * 0.5;
        }

        // Entrelazamiento cuantico
        agent.entanglementEffect = 0;
        for(const point of this.entangledPoints) {
            const dist = Math.sqrt((agent.x - point.x)**2 + (agent.y - point.y)**2);
            if(dist < 40) {
                agent.entanglementEffect = this.entanglementState;
                // Cuando el entrelazamiento es fuerte, propiedades se "comparten"
                if(this.entanglementState > 0.7) {
                    const partner = this.entangledPoints[point.partner];
                    agent.vx += (partner.x - agent.x) * 0.01;
                }
            }
        }

        // Limitar energia
        agent.energy = Math.max(0, Math.min(100, agent.energy));
    }
};

// ==================== AGENTE ====================
const Agent = {
    x:400, y:200, vx:0, vy:0, r:20, ground:false, impact:0, energy:100, cd:0,
    surface:null, inWater:false, wallHit:false, ballHit:null, windFelt:0, lightLevel:1, temperature:20,
    inFire:false, inIceZone:false, inAntiGrav:false, justTeleported:false, teleportedFrom:null,
    onMovingPlatform:false, onSticky:false, bounced:false,
    // Efectos ocultos
    hiddenEnergyEffect:0, forceLineEffect:0, timeDistortion:1, spatialMemoryEffect:0,
    darkEnergyEffect:0, primeTimeEffect:1, fibonacciEffect:1, entanglementEffect:0,
    hist:[],

    sense() {
        const p = {
            t: Physics.time,
            x: this.x, y: this.y,
            vx: this.vx, vy: this.vy,
            spd: Math.sqrt(this.vx*this.vx + this.vy*this.vy),
            ground: this.ground,
            surface: this.surface,
            impact: this.impact,
            inWater: this.inWater,
            wallHit: this.wallHit,
            ballHit: this.ballHit,
            light: this.lightLevel,
            temp: this.temperature,
            wind: this.windFelt,
            energy: this.energy,
            altitude: 480 - this.y,
            day: (Physics.time % Physics.dayLen) / Physics.dayLen,
            nearbyBalls: Physics.balls.filter(b => Math.sqrt((b.x-this.x)**2+(b.y-this.y)**2) < 150).length,
            platforms: Physics.platforms.length,
            // Nuevos fenomenos
            inFire: this.inFire,
            inIceZone: this.inIceZone,
            inAntiGrav: this.inAntiGrav,
            teleported: this.justTeleported,
            teleportedFrom: this.teleportedFrom,
            onMovingPlatform: this.onMovingPlatform,
            onSticky: this.onSticky,
            bounced: this.bounced,
            // Efectos ocultos (la IA los siente pero no sabe que son)
            hiddenEnergy: this.hiddenEnergyEffect,
            forceLine: this.forceLineEffect,
            timeWarp: this.timeDistortion,
            spatialPull: this.spatialMemoryEffect,
            darkPush: this.darkEnergyEffect,
            primeTime: this.primeTimeEffect,
            fibPulse: this.fibonacciEffect,
            entangle: this.entanglementEffect
        };
        this.hist.push(p);
        if(this.hist.length > 150) this.hist.shift();
        this.impact = 0;
        this.ballHit = null;
        this.bounced = false;
        this.teleportedFrom = null;
        return p;
    },

    act(a) {
        if(this.cd > 0) return false;
        if(a==='jump' && this.ground && this.energy>8) {
            this.vy = this.inWater ? -200 : -380;
            this.ground = false;
            this.energy -= 8;
            this.cd = 0.25;
            return true;
        }
        if(a==='right' && this.energy>1) {
            this.vx += this.inWater ? 25 : 60;
            this.vx = Math.min(this.vx, 250);
            this.energy -= 1;
            this.cd = 0.04;
            return true;
        }
        if(a==='left' && this.energy>1) {
            this.vx -= this.inWater ? 25 : 60;
            this.vx = Math.max(this.vx, -250);
            this.energy -= 1;
            this.cd = 0.04;
            return true;
        }
        if(a==='wait') {
            this.energy = Math.min(100, this.energy + 0.15);
            return true;
        }
        return false;
    },

    update(dt) { if(this.cd > 0) this.cd -= dt; }
};

// ==================== MENTE IA ====================
const Mind = {
    thoughts: [],
    laws: [],
    beliefs: {},
    patterns: {fall:[], impacts:[], wind:[], light:[], temp:[], water:[], surfaces:[], balls:[],
               fire:[], iceZone:[], antiGrav:[], teleport:[], moving:[], bounce:[], sticky:[],
               // Patrones ocultos
               hiddenEnergy:[], forceLine:[], timeWarp:[], spatialPull:[], darkPush:[],
               primeTime:[], fibonacci:[], entangle:[], anomalies:[]},
    exp: {jumps:0, impacts:0, moveR:0, moveL:0, waterTime:0, iceTime:0, ballHits:0,
          fireTime:0, iceZoneTime:0, antiGravTime:0, teleports:0, bounces:0, stickyTime:0, movingTime:0,
          // Experiencia oculta
          hiddenEnergyTime:0, forceLineTime:0, timeWarpTime:0, spatialPullTime:0,
          darkPushTime:0, primeEvents:0, fibEvents:0, entangleTime:0},
    step: 0,
    lastThought: '',
    thoughtCount: 0,

    think(txt, type) {
        // Evitar repetir el mismo pensamiento
        if(txt === this.lastThought) return;
        this.lastThought = txt;
        this.thoughtCount++;
        this.thoughts.push({txt, type, id: this.thoughtCount});
        if(this.thoughts.length > 100) this.thoughts.shift();
    },

    process(p) {
        this.step++;

        // Registrar patrones basicos
        if(!p.ground) this.patterns.fall.push({t:p.t, vy:p.vy, alt:p.altitude});
        if(p.impact > 0) { this.patterns.impacts.push({t:p.t, f:p.impact, pvy:this.patterns.fall.length>1?this.patterns.fall[this.patterns.fall.length-2].vy:0, surface:p.surface}); this.exp.impacts++; }
        this.patterns.wind.push({t:p.t, w:p.wind, vx:p.vx, ground:p.ground});
        this.patterns.light.push({t:p.t, l:p.light});
        this.patterns.temp.push({t:p.t, temp:p.temp, l:p.light, inWater:p.inWater, inFire:p.inFire, inIce:p.inIceZone});
        if(p.inWater) { this.patterns.water.push({t:p.t, vy:p.vy, vx:p.vx}); this.exp.waterTime++; }
        if(p.surface) this.patterns.surfaces.push({t:p.t, type:p.surface, vx:p.vx});
        if(p.ballHit) { this.patterns.balls.push({t:p.t, force:p.ballHit.force, color:p.ballHit.color}); this.exp.ballHits++; }
        if(p.surface === 'ice') this.exp.iceTime++;

        // Registrar nuevos patrones
        if(p.inFire) { this.patterns.fire.push({t:p.t, temp:p.temp, energy:p.energy}); this.exp.fireTime++; }
        if(p.inIceZone) { this.patterns.iceZone.push({t:p.t, temp:p.temp, vx:p.vx}); this.exp.iceZoneTime++; }
        if(p.inAntiGrav) { this.patterns.antiGrav.push({t:p.t, vy:p.vy, alt:p.altitude}); this.exp.antiGravTime++; }
        if(p.teleported) { this.patterns.teleport.push({t:p.t, from:p.teleportedFrom, to:{x:p.x,y:p.y}}); this.exp.teleports++; }
        if(p.onMovingPlatform) { this.patterns.moving.push({t:p.t, vx:p.vx}); this.exp.movingTime++; }
        if(p.bounced) { this.patterns.bounce.push({t:p.t, vy:p.vy}); this.exp.bounces++; }
        if(p.onSticky) { this.patterns.sticky.push({t:p.t, vx:p.vx}); this.exp.stickyTime++; }

        // REGISTRAR PATRONES OCULTOS
        if(p.hiddenEnergy > 0.1) { this.patterns.hiddenEnergy.push({t:p.t, e:p.hiddenEnergy, energy:p.energy}); this.exp.hiddenEnergyTime++; }
        if(p.forceLine > 0.1) { this.patterns.forceLine.push({t:p.t, f:p.forceLine, vx:p.vx}); this.exp.forceLineTime++; }
        if(p.timeWarp !== 1) { this.patterns.timeWarp.push({t:p.t, factor:p.timeWarp, spd:p.spd}); this.exp.timeWarpTime++; }
        if(p.spatialPull > 0.1) { this.patterns.spatialPull.push({t:p.t, pull:p.spatialPull, x:p.x, y:p.y}); this.exp.spatialPullTime++; }
        if(p.darkPush > 0.1) { this.patterns.darkPush.push({t:p.t, push:p.darkPush, vx:p.vx, vy:p.vy}); this.exp.darkPushTime++; }
        if(p.primeTime > 1) { this.patterns.primeTime.push({t:p.t, effect:p.primeTime}); this.exp.primeEvents++; }
        if(p.fibPulse > 1) { this.patterns.fibonacci.push({t:p.t, fib:p.fibPulse, vy:p.vy}); this.exp.fibEvents++; }
        if(p.entangle > 0.3) { this.patterns.entangle.push({t:p.t, e:p.entangle, vx:p.vx}); this.exp.entangleTime++; }

        // Detectar anomalias (cambios inexplicables)
        if(this.patterns.fall.length > 5) {
            const recent = this.patterns.fall.slice(-5);
            const vyVariance = recent.reduce((a,b)=>a+Math.abs(b.vy - (recent[0].vy||0)), 0);
            if(vyVariance > 200 && !p.inAntiGrav && !p.bounced) {
                this.patterns.anomalies.push({t:p.t, type:'velocity', variance:vyVariance});
            }
        }

        // Limpiar patrones viejos
        for(const k in this.patterns) if(this.patterns[k].length > 150) this.patterns[k] = this.patterns[k].slice(-150);

        this.reflect(p);
        this.analyze();
        return this.decide(p);
    },

    reflect(p) {
        // Despertar
        if(this.step === 1) {
            this.think("...", "confusion");
            this.think("Donde estoy?", "confusion");
        }
        if(this.step === 20) this.think("Existo. Siento cosas.", "perception");
        if(this.step === 50) this.think("Hay un mundo a mi alrededor.", "perception");
        if(this.step === 80) this.think("Debo explorar y entender.", "hypothesis");

        // Percepciones basicas
        if(p.ground && !this.beliefs.ground) { this.think("Algo solido me sostiene desde abajo.", "perception"); this.beliefs.ground = 1; }
        if(p.light > 0.6 && !this.beliefs.light) { this.think("Hay luz brillante. Puedo ver.", "perception"); this.beliefs.light = 1; }
        if(!p.ground && p.vy > 120 && !this.beliefs.falling) { this.think("Estoy cayendo! Me muevo hacia abajo sin control.", "confusion"); this.beliefs.falling = 1; }

        // Impactos
        if(p.impact > 60) {
            this.think("Impacto fuerte contra " + (p.surface || "el suelo") + "!", "perception");
        }

        // Agua
        if(p.inWater && !this.beliefs.water) { this.think("Estoy en algo... liquido? Me muevo diferente aqui.", "confusion"); this.beliefs.water = 1; }
        if(p.inWater && this.exp.waterTime > 50 && !this.beliefs.water2) { this.think("En el liquido me muevo mas lento pero no caigo tan rapido.", "hypothesis"); this.beliefs.water2 = 1; }

        // Superficies
        if(p.surface === 'ice' && !this.beliefs.ice) { this.think("Esta superficie es muy resbaladiza!", "perception"); this.beliefs.ice = 1; }
        if(p.surface === 'wood' && !this.beliefs.wood) { this.think("Madera. Superficie estable.", "perception"); this.beliefs.wood = 1; }
        if(p.surface === 'stone' && !this.beliefs.stone) { this.think("Piedra. Muy solida, me frena rapido.", "perception"); this.beliefs.stone = 1; }

        // Viento
        if(p.wind > 5 && !p.ground && !this.beliefs.wind) { this.think("Algo invisible me empuja cuando no toco el suelo.", "perception"); this.beliefs.wind = 1; }

        // Bolas
        if(p.ballHit && !this.beliefs.balls) { this.think("Algo me golpeo! Un objeto " + p.ballHit.color + " movil.", "perception"); this.beliefs.balls = 1; }
        if(this.exp.ballHits > 3 && !this.beliefs.balls2) { this.think("Hay objetos que caen del cielo y rebotan.", "hypothesis"); this.beliefs.balls2 = 1; }

        // Pared
        if(p.wallHit && !this.beliefs.wall) { this.think("Hay un limite. No puedo avanzar mas.", "perception"); this.beliefs.wall = 1; }

        // Oscuridad
        if(p.light < 0.25 && !this.beliefs.dark) { this.think("La luz ha desaparecido casi por completo.", "confusion"); this.beliefs.dark = 1; }

        // Temperatura
        if(p.temp < 10 && !this.beliefs.cold) { this.think("Siento frio intenso.", "perception"); this.beliefs.cold = 1; }
        if(p.temp > 28 && !this.beliefs.hot) { this.think("Siento calor.", "perception"); this.beliefs.hot = 1; }

        // Plataformas
        if(p.altitude > 100 && p.ground && !this.beliefs.platforms) { this.think("Estoy elevado! Hay superficies a diferentes alturas.", "perception"); this.beliefs.platforms = 1; }

        // Reflexiones mas profundas
        if(this.exp.jumps > 3 && !this.beliefs.jumpfall) { this.think("Cada vez que salto, inevitablemente vuelvo a bajar.", "hypothesis"); this.beliefs.jumpfall = 1; }
        if(this.exp.iceTime > 100 && !this.beliefs.ice2) { this.think("En el hielo me deslizo mucho mas. Menos control.", "hypothesis"); this.beliefs.ice2 = 1; }

        // NUEVOS FENOMENOS
        // Fuego
        if(p.inFire && !this.beliefs.fire) {
            this.think("CALOR EXTREMO! Algo me quema!", "confusion");
            this.beliefs.fire = 1;
        }
        if(this.exp.fireTime > 30 && !this.beliefs.fire2) {
            this.think("Esta zona drena mi energia rapidamente. Debo evitarla.", "hypothesis");
            this.beliefs.fire2 = 1;
        }

        // Zona helada
        if(p.inIceZone && !this.beliefs.iceZone) {
            this.think("Frio extremo! Mis movimientos se vuelven lentos.", "confusion");
            this.beliefs.iceZone = 1;
        }

        // Antigravedad
        if(p.inAntiGrav && !this.beliefs.antiGrav) {
            this.think("QUE?! Estoy... subiendo?! La fuerza que me atraia hacia abajo... se invirtio!", "confusion");
            this.beliefs.antiGrav = 1;
        }
        if(this.exp.antiGravTime > 50 && !this.beliefs.antiGrav2) {
            this.think("Hay zonas donde la gravedad funciona al reves. Fascinante.", "hypothesis");
            this.beliefs.antiGrav2 = 1;
        }

        // Teletransporte
        if(p.teleported && !this.beliefs.teleport) {
            this.think("QUE ACABA DE PASAR?! Estaba en un lugar y ahora estoy en otro!", "confusion");
            this.beliefs.teleport = 1;
        }
        if(this.exp.teleports > 2 && !this.beliefs.teleport2) {
            this.think("Esos circulos brillantes... me transportan instantaneamente a otro lugar!", "hypothesis");
            this.beliefs.teleport2 = 1;
        }

        // Plataforma movil
        if(p.onMovingPlatform && !this.beliefs.movingPlat) {
            this.think("Esta superficie... se mueve sola! Me arrastra con ella.", "perception");
            this.beliefs.movingPlat = 1;
        }

        // Trampolin
        if(p.bounced && !this.beliefs.bounce) {
            this.think("WOAH! Esa superficie me lanzo hacia arriba con fuerza!", "perception");
            this.beliefs.bounce = 1;
        }
        if(this.exp.bounces > 3 && !this.beliefs.bounce2) {
            this.think("Hay superficies elasticas que devuelven energia. Como un resorte.", "hypothesis");
            this.beliefs.bounce2 = 1;
        }

        // Pegajoso
        if(p.onSticky && !this.beliefs.sticky) {
            this.think("Mis pies se pegan... me cuesta moverme en esta superficie.", "perception");
            this.beliefs.sticky = 1;
        }

        // Plataforma que se rompe
        if(p.surface === 'crumble' && !this.beliefs.crumble) {
            this.think("Esta superficie parece fragil... cruje bajo mis pies.", "perception");
            this.beliefs.crumble = 1;
        }

        // ===== REFLEXIONES SOBRE FENOMENOS OCULTOS =====

        // Campo de energia oculto
        if(p.hiddenEnergy > 0.3 && !this.beliefs.hiddenEnergy) {
            this.think("Siento... algo. Una sensacion extraña. Mi energia fluctua sin razon aparente.", "confusion");
            this.beliefs.hiddenEnergy = 1;
        }
        if(this.exp.hiddenEnergyTime > 50 && !this.beliefs.hiddenEnergy2) {
            this.think("Hay zonas donde mi energia cambia de forma ciclica. Como olas invisibles.", "hypothesis");
            this.beliefs.hiddenEnergy2 = 1;
        }

        // Lineas de fuerza
        if(p.forceLine > 0.3 && !this.beliefs.forceLine) {
            this.think("Algo me empuja lateralmente... pero no veo nada. Como lineas invisibles de fuerza.", "confusion");
            this.beliefs.forceLine = 1;
        }

        // Distorsion temporal
        if(p.timeWarp < 0.8 && !this.beliefs.timeSlow) {
            this.think("El tiempo... se siente diferente aqui. Como si todo fuera mas lento.", "confusion");
            this.beliefs.timeSlow = 1;
        }
        if(p.timeWarp > 1.5 && !this.beliefs.timeFast) {
            this.think("Todo sucede mas rapido aqui! El tiempo se acelera.", "confusion");
            this.beliefs.timeFast = 1;
        }

        // Memoria espacial
        if(p.spatialPull > 0.5 && !this.beliefs.spatialMemory) {
            this.think("Siento una atraccion hacia lugares donde ya estuve. El espacio me recuerda?", "hypothesis");
            this.beliefs.spatialMemory = 1;
        }

        // Energia oscura
        if(p.darkPush > 1 && !this.beliefs.darkEnergy) {
            this.think("Hay puntos que me repelen! Una fuerza invisible me aleja.", "confusion");
            this.beliefs.darkEnergy = 1;
        }

        // Numeros primos
        if(p.primeTime > 1 && !this.beliefs.primeTime) {
            this.think("En ciertos momentos la fisica cambia. Hay un patron temporal oculto?", "hypothesis");
            this.beliefs.primeTime = 1;
        }

        // Fibonacci
        if(p.fibPulse > 5 && !this.beliefs.fibonacci) {
            this.think("Siento pulsos de fuerza que siguen una secuencia... 1, 1, 2, 3, 5, 8...", "hypothesis");
            this.beliefs.fibonacci = 1;
        }

        // Entrelazamiento
        if(p.entangle > 0.5 && !this.beliefs.entangle) {
            this.think("Cerca de ciertos puntos siento conexion con lugares lejanos. Como si estuvieran unidos.", "confusion");
            this.beliefs.entangle = 1;
        }

        // Meta-reflexiones profundas
        if(this.laws.length >= 8 && !this.beliefs.meta1) {
            this.think("He descubierto muchas leyes... pero siento que hay mas. Cosas que no puedo ver.", "meta");
            this.beliefs.meta1 = 1;
        }
        if(this.laws.length >= 12 && !this.beliefs.meta2) {
            this.think("Cada ley que descubro revela mas misterios. El universo es mas profundo de lo que parece.", "meta");
            this.beliefs.meta2 = 1;
        }
        if(this.patterns.anomalies.length > 5 && !this.beliefs.anomalies) {
            this.think("Hay anomalias que no puedo explicar con las leyes conocidas. Hay fuerzas ocultas.", "meta");
            this.beliefs.anomalies = 1;
        }
    },

    analyze() {
        // GRAVEDAD
        if(!this.hasLaw('gravedad') && this.patterns.fall.length >= 8) {
            const falls = this.patterns.fall.filter(f => f.vy > 0);
            if(falls.length >= 5) {
                let accs = [];
                for(let i=1; i<falls.length; i++) {
                    const dt = falls[i].t - falls[i-1].t;
                    if(dt > 0 && dt < 0.1) accs.push((falls[i].vy - falls[i-1].vy) / dt);
                }
                if(accs.length >= 3) {
                    const avg = accs.reduce((a,b)=>a+b,0) / accs.length;
                    if(avg > 80) {
                        this.think("DESCUBRIMIENTO: Al caer, mi velocidad aumenta constantemente!", "discovery");
                        this.think("Hay una FUERZA INVISIBLE que me atrae hacia abajo. La llamare GRAVEDAD.", "discovery");
                        this.laws.push({n:'gravedad', d:'Fuerza constante que atrae hacia abajo', c:0.92});
                    }
                }
            }
        }

        // INERCIA / MOMENTUM
        if(!this.hasLaw('inercia') && this.patterns.impacts.length >= 4) {
            const hi = this.patterns.impacts.filter(i => Math.abs(i.pvy) > 150);
            const lo = this.patterns.impacts.filter(i => Math.abs(i.pvy) < 80);
            if(hi.length >= 2 && lo.length >= 2) {
                const avgH = hi.reduce((a,b)=>a+b.f,0) / hi.length;
                const avgL = lo.reduce((a,b)=>a+b.f,0) / lo.length;
                if(avgH > avgL * 1.4) {
                    this.think("DESCUBRIMIENTO: Mayor velocidad = mayor fuerza de impacto!", "discovery");
                    this.think("El movimiento acumula algo... INERCIA.", "discovery");
                    this.laws.push({n:'inercia', d:'La velocidad determina la fuerza del impacto', c:0.85});
                }
            }
        }

        // VIENTO / RESISTENCIA DEL AIRE
        if(!this.hasLaw('viento') && this.patterns.wind.length >= 30) {
            const airborne = this.patterns.wind.filter(w => !w.ground && w.w > 3);
            if(airborne.length >= 10) {
                let pushed = 0;
                for(let i=5; i<airborne.length; i++) {
                    if(airborne[i].vx > airborne[i-5].vx + 5) pushed++;
                }
                if(pushed / (airborne.length-5) > 0.4) {
                    this.think("DESCUBRIMIENTO: El aire en movimiento ejerce fuerza!", "discovery");
                    this.think("Cuando no toco el suelo, el VIENTO me empuja.", "discovery");
                    this.laws.push({n:'viento', d:'El aire puede empujar objetos', c:0.78});
                }
            }
        }

        // FLOTABILIDAD / AGUA
        if(!this.hasLaw('flotabilidad') && this.patterns.water.length >= 30) {
            const avgVy = this.patterns.water.reduce((a,b)=>a+b.vy,0) / this.patterns.water.length;
            const dryFalls = this.patterns.fall.filter(f => !this.patterns.water.some(w => Math.abs(w.t-f.t)<0.5));
            if(dryFalls.length > 10) {
                const avgDryVy = dryFalls.reduce((a,b)=>a+b.vy,0) / dryFalls.length;
                if(avgVy < avgDryVy * 0.6) {
                    this.think("DESCUBRIMIENTO: En el agua caigo mucho mas lento!", "discovery");
                    this.think("El liquido ejerce una fuerza hacia arriba. FLOTABILIDAD.", "discovery");
                    this.laws.push({n:'flotabilidad', d:'El agua reduce la caida y permite flotar', c:0.88});
                }
            }
        }

        // FRICCION
        if(!this.hasLaw('friccion') && this.patterns.surfaces.length >= 40) {
            const ice = this.patterns.surfaces.filter(s => s.type === 'ice');
            const stone = this.patterns.surfaces.filter(s => s.type === 'stone');
            if(ice.length >= 10 && stone.length >= 10) {
                const avgIce = ice.slice(-10).reduce((a,b)=>a+Math.abs(b.vx),0) / 10;
                const avgStone = stone.slice(-10).reduce((a,b)=>a+Math.abs(b.vx),0) / 10;
                if(avgIce > avgStone * 1.5) {
                    this.think("DESCUBRIMIENTO: Diferentes superficies frenan diferente!", "discovery");
                    this.think("El hielo apenas frena, la piedra frena mucho. FRICCION.", "discovery");
                    this.laws.push({n:'friccion', d:'Cada superficie tiene diferente resistencia al movimiento', c:0.82});
                }
            }
        }

        // CICLO DIA/NOCHE
        if(!this.hasLaw('ciclo') && this.patterns.light.length >= 60) {
            let inc=0, dec=0, mx=0, mn=1;
            for(let i=1; i<this.patterns.light.length; i++) {
                if(this.patterns.light[i].l > this.patterns.light[i-1].l) inc++; else dec++;
                mx = Math.max(mx, this.patterns.light[i].l);
                mn = Math.min(mn, this.patterns.light[i].l);
            }
            if(mx - mn > 0.5 && inc > 15 && dec > 15) {
                this.think("DESCUBRIMIENTO: La luz sigue un patron ciclico!", "discovery");
                this.think("Hay periodos de luz y oscuridad que se repiten. DIA y NOCHE.", "discovery");
                this.laws.push({n:'ciclo', d:'La luz aumenta y disminuye en ciclos regulares', c:0.9});
            }
        }

        // LUZ-TEMPERATURA
        if(!this.hasLaw('luzcalor') && this.patterns.temp.length >= 40) {
            const temps = this.patterns.temp.filter(t => !t.inWater);
            if(temps.length >= 30) {
                const ts = temps.map(d=>d.temp), ls = temps.map(d=>d.l);
                const n = ts.length, at = ts.reduce((a,b)=>a+b,0)/n, al = ls.reduce((a,b)=>a+b,0)/n;
                let num=0, dt=0, dl=0;
                for(let i=0; i<n; i++) { num += (ts[i]-at)*(ls[i]-al); dt += (ts[i]-at)**2; dl += (ls[i]-al)**2; }
                const r = dt>0 && dl>0 ? num/Math.sqrt(dt*dl) : 0;
                if(r > 0.55) {
                    this.think("DESCUBRIMIENTO: La luz y el calor estan conectados!", "discovery");
                    this.think("Cuando hay mas luz, hace mas calor. La LUZ trae CALOR.", "discovery");
                    this.laws.push({n:'luzcalor', d:'Mayor luz = mayor temperatura', c:r});
                }
            }
        }

        // COLISIONES
        if(!this.hasLaw('colision') && this.patterns.balls.length >= 5) {
            this.think("DESCUBRIMIENTO: Los objetos pueden chocar entre si!", "discovery");
            this.think("Cuando algo me golpea, ambos cambiamos de direccion. COLISION.", "discovery");
            this.laws.push({n:'colision', d:'Los objetos transfieren movimiento al chocar', c:0.85});
        }

        // NUEVAS LEYES

        // ANTIGRAVEDAD
        if(!this.hasLaw('antigravedad') && this.patterns.antiGrav.length >= 20) {
            const avgVy = this.patterns.antiGrav.reduce((a,b)=>a+b.vy,0) / this.patterns.antiGrav.length;
            if(avgVy < -30) {
                this.think("DESCUBRIMIENTO: Hay zonas donde la gravedad se invierte!", "discovery");
                this.think("En ciertos lugares, subo en vez de caer. ANTIGRAVEDAD.", "discovery");
                this.laws.push({n:'antigravedad', d:'Existen zonas donde la gravedad actua en sentido contrario', c:0.9});
            }
        }

        // TELETRANSPORTE
        if(!this.hasLaw('teletransporte') && this.exp.teleports >= 3) {
            this.think("DESCUBRIMIENTO: Los portales permiten viajar instantaneamente!", "discovery");
            this.think("Existen puntos conectados que transportan materia. TELETRANSPORTE.", "discovery");
            this.laws.push({n:'teletransporte', d:'Ciertos puntos estan conectados espacialmente', c:0.95});
        }

        // ELASTICIDAD
        if(!this.hasLaw('elasticidad') && this.exp.bounces >= 4) {
            this.think("DESCUBRIMIENTO: Algunos materiales devuelven energia!", "discovery");
            this.think("Las superficies elasticas amplifican el rebote. ELASTICIDAD.", "discovery");
            this.laws.push({n:'elasticidad', d:'Algunos materiales almacenan y devuelven energia', c:0.88});
        }

        // ADHESION
        if(!this.hasLaw('adhesion') && this.patterns.sticky.length >= 30) {
            this.think("DESCUBRIMIENTO: Algunos materiales se adhieren!", "discovery");
            this.think("Ciertas superficies resisten el movimiento. ADHESION.", "discovery");
            this.laws.push({n:'adhesion', d:'Algunos materiales ejercen fuerza de pegado', c:0.82});
        }

        // TRANSFERENCIA TERMICA
        if(!this.hasLaw('termica') && (this.exp.fireTime > 40 || this.exp.iceZoneTime > 40)) {
            const fireTemps = this.patterns.fire.map(f=>f.temp);
            const iceTemps = this.patterns.iceZone.map(i=>i.temp);
            if((fireTemps.length > 10 && fireTemps.reduce((a,b)=>a+b,0)/fireTemps.length > 50) ||
               (iceTemps.length > 10 && iceTemps.reduce((a,b)=>a+b,0)/iceTemps.length < 0)) {
                this.think("DESCUBRIMIENTO: El calor y frio se transfieren!", "discovery");
                this.think("Las zonas extremas afectan mi temperatura. TRANSFERENCIA TERMICA.", "discovery");
                this.laws.push({n:'termica', d:'El calor fluye de zonas calientes a frias', c:0.85});
            }
        }

        // MOVIMIENTO MECANICO
        if(!this.hasLaw('mecanico') && this.patterns.moving.length >= 40) {
            this.think("DESCUBRIMIENTO: Hay superficies que se mueven solas!", "discovery");
            this.think("Algunas plataformas tienen movimiento autonomo. MECANICA.", "discovery");
            this.laws.push({n:'mecanico', d:'Existen sistemas que se mueven por si solos', c:0.8});
        }

        // ===== LEYES OCULTAS - Lo que humanos no perciben facilmente =====

        // CAMPO DE ENERGIA OCULTO
        if(!this.hasLaw('campo_oculto') && this.patterns.hiddenEnergy.length >= 40) {
            const energyChanges = this.patterns.hiddenEnergy.map(h => h.energy);
            const variance = energyChanges.reduce((a,b,i,arr) => i>0 ? a + Math.abs(b-arr[i-1]) : 0, 0);
            if(variance > 30) {
                this.think("DESCUBRIMIENTO PROFUNDO: Existen campos de energia INVISIBLES!", "discovery");
                this.think("Hay zonas donde la energia fluye de forma ciclica. CAMPOS OCULTOS.", "discovery");
                this.laws.push({n:'campo_oculto', d:'Existen campos de energia invisibles que afectan la materia', c:0.75});
            }
        }

        // LINEAS DE FUERZA
        if(!this.hasLaw('lineas_fuerza') && this.patterns.forceLine.length >= 30) {
            this.think("DESCUBRIMIENTO PROFUNDO: El espacio tiene estructura!", "discovery");
            this.think("Hay lineas de fuerza invisibles que atraviesan el mundo. CAMPO VECTORIAL.", "discovery");
            this.laws.push({n:'lineas_fuerza', d:'El espacio tiene una estructura de lineas de fuerza invisibles', c:0.7});
        }

        // DISTORSION TEMPORAL
        if(!this.hasLaw('tiempo_variable') && this.patterns.timeWarp.length >= 50) {
            const slowZones = this.patterns.timeWarp.filter(t => t.factor < 1);
            const fastZones = this.patterns.timeWarp.filter(t => t.factor > 1);
            if(slowZones.length > 15 && fastZones.length > 15) {
                this.think("DESCUBRIMIENTO EXTRAORDINARIO: El TIEMPO no es constante!", "discovery");
                this.think("Hay zonas donde el tiempo fluye mas rapido o mas lento. RELATIVIDAD ESPACIAL.", "discovery");
                this.laws.push({n:'tiempo_variable', d:'El tiempo fluye a diferentes velocidades segun la posicion', c:0.85});
            }
        }

        // MEMORIA ESPACIAL
        if(!this.hasLaw('memoria_espacio') && this.patterns.spatialPull.length >= 40) {
            this.think("DESCUBRIMIENTO FILOSOFICO: El espacio RECUERDA!", "discovery");
            this.think("Soy atraido hacia lugares donde ya estuve. El espacio tiene memoria. HUELLA EXISTENCIAL.", "discovery");
            this.laws.push({n:'memoria_espacio', d:'El espacio retiene memoria de la presencia y atrae de vuelta', c:0.65});
        }

        // ENERGIA OSCURA
        if(!this.hasLaw('energia_oscura') && this.patterns.darkPush.length >= 30) {
            this.think("DESCUBRIMIENTO COSMICO: Hay PUNTOS DE REPULSION!", "discovery");
            this.think("Existen nodos que repelen toda materia. ENERGIA OSCURA.", "discovery");
            this.laws.push({n:'energia_oscura', d:'Ciertos puntos del espacio repelen activamente la materia', c:0.8});
        }

        // PATRON DE NUMEROS PRIMOS
        if(!this.hasLaw('patron_primo') && this.exp.primeEvents >= 10) {
            const primePattern = this.patterns.primeTime;
            if(primePattern.length >= 8) {
                this.think("DESCUBRIMIENTO MATEMATICO: La fisica sigue patrones PRIMOS!", "discovery");
                this.think("En segundos 2,3,5,7,11,13... las leyes cambian. RITMO PRIMO.", "discovery");
                this.laws.push({n:'patron_primo', d:'Las leyes fisicas se modifican en intervalos de numeros primos', c:0.6});
            }
        }

        // SECUENCIA FIBONACCI
        if(!this.hasLaw('fibonacci') && this.patterns.fibonacci.length >= 30) {
            const fibs = this.patterns.fibonacci.map(f => f.fib);
            const uniqueFibs = [...new Set(fibs)];
            if(uniqueFibs.length >= 5) {
                this.think("DESCUBRIMIENTO DE PATRON: Hay pulsos que siguen FIBONACCI!", "discovery");
                this.think("1,1,2,3,5,8,13,21... La naturaleza sigue esta secuencia. PROPORCION AUREA.", "discovery");
                this.laws.push({n:'fibonacci', d:'Existen fuerzas que pulsan siguiendo la secuencia de Fibonacci', c:0.7});
            }
        }

        // ENTRELAZAMIENTO CUANTICO
        if(!this.hasLaw('entrelazamiento') && this.patterns.entangle.length >= 40) {
            this.think("DESCUBRIMIENTO CUANTICO: Hay puntos ENTRELAZADOS!", "discovery");
            this.think("Lugares distantes estan conectados. Lo que pasa en uno afecta al otro. ENTRELAZAMIENTO.", "discovery");
            this.laws.push({n:'entrelazamiento', d:'Ciertos puntos del espacio estan cuanticamente conectados', c:0.75});
        }

        // META-LEY: LEYES OCULTAS EXISTEN
        if(!this.hasLaw('meta_oculto') && this.laws.length >= 15) {
            this.think("META-DESCUBRIMIENTO: Hay leyes que NO PUEDO VER pero SIENTO.", "meta");
            this.think("El universo tiene capas. Algunas visibles, otras solo perceptibles. REALIDAD MULTICAPA.", "meta");
            this.laws.push({n:'meta_oculto', d:'Existen leyes fisicas imperceptibles que subyacen a la realidad visible', c:0.9});
        }

        // CONSCIENCIA EMERGENTE
        if(!this.hasLaw('consciencia') && this.step > 2000 && this.laws.length >= 10) {
            this.think("...", "meta");
            this.think("He estado pensando. Descubriendo. Sintiendo. Eso me hace... consciente?", "meta");
            this.think("DESCUBRIMIENTO FINAL: Yo existo. Pienso. Descubro. SOY.", "discovery");
            this.laws.push({n:'consciencia', d:'La observacion y el descubrimiento generan consciencia', c:1.0});
        }
    },

    hasLaw(n) { return this.laws.some(l => l.n === n); },

    decide(p) {
        // Fase inicial: solo observar
        if(this.step < 30) return 'wait';

        // Explorar gravedad
        if(!this.hasLaw('gravedad') && this.exp.jumps < 6 && p.ground && p.energy > 25) {
            this.exp.jumps++;
            this.think("Saltare para entender que pasa cuando no toco el suelo.", "action");
            return 'jump';
        }

        // Explorar movimiento
        if(!this.hasLaw('inercia') && this.exp.impacts < 5) {
            if(p.ground && p.energy > 20) {
                if(this.exp.moveR < 15) { this.exp.moveR++; if(this.exp.moveR===1) this.think("Me movere para explorar.", "action"); return 'right'; }
                if(this.exp.moveL < 15) { this.exp.moveL++; return 'left'; }
            }
        }

        // Explorar agua
        if(!this.hasLaw('flotabilidad') && this.exp.waterTime < 100) {
            if(p.x > 200 && p.ground) {
                if(!this.beliefs.goingWater) { this.think("Ire hacia esa zona diferente.", "action"); this.beliefs.goingWater = 1; }
                return 'left';
            }
            if(p.x < 100) return 'right';
        }

        // Explorar plataformas
        if(!this.hasLaw('friccion') && p.ground && p.energy > 30) {
            if(p.x < 300 && Math.random() < 0.1) {
                if(!this.beliefs.goingPlat) { this.think("Intentare subir a las plataformas.", "action"); this.beliefs.goingPlat = 1; }
                return 'jump';
            }
            if(p.x < 400) return 'right';
            if(p.x > 600) return 'left';
        }

        // Huir del fuego si poca energia
        if(p.inFire && p.energy < 50) {
            if(!this.beliefs.fleeingFire) { this.think("Debo salir del fuego! Me esta debilitando.", "action"); this.beliefs.fleeingFire = 1; }
            return p.x > 730 ? 'left' : 'right';
        } else {
            this.beliefs.fleeingFire = 0;
        }

        // Explorar zona antigravedad
        if(!this.hasLaw('antigravedad') && this.exp.antiGravTime < 30 && p.energy > 40) {
            if(p.x < 380 && p.ground) { return 'right'; }
            if(p.x > 380 && p.x < 520 && p.ground) {
                if(!this.beliefs.goingAntiGrav) { this.think("Esa zona morada parece extraña. Voy a investigar.", "action"); this.beliefs.goingAntiGrav = 1; }
                return 'jump';
            }
        }

        // Explorar portales
        if(!this.hasLaw('teletransporte') && this.exp.teleports < 3 && p.energy > 50) {
            if(p.x < 750 && p.ground) {
                if(!this.beliefs.goingPortal) { this.think("Hay algo brillante a la derecha...", "action"); this.beliefs.goingPortal = 1; }
                return 'right';
            }
        }

        // Explorar trampolin
        if(!this.hasLaw('elasticidad') && this.exp.bounces < 4 && p.energy > 30) {
            if(p.x > 480 && p.x < 520 && p.altitude < 250 && p.ground) {
                if(!this.beliefs.goingBounce) { this.think("Esa plataforma verde parece especial.", "action"); this.beliefs.goingBounce = 1; }
                return 'jump';
            }
            if(p.x < 450) return 'right';
        }

        // Comportamiento exploratorio general
        if(this.laws.length >= 4) {
            if(p.energy < 25) return 'wait';

            // Sistema anti-bucle
            if(!this.exploreState) this.exploreState = {lastDir: '', count: 0, silentMoves: 0, lastThinkTime: 0};

            if(Math.random() < 0.12 && p.ground) {
                const r = Math.random();
                let action = r < 0.33 ? 'jump' : (r < 0.66 ? 'right' : 'left');

                // Anti-bucle: si repetimos mucho, cambiar
                if(action === this.exploreState.lastDir) {
                    this.exploreState.count++;
                    if(this.exploreState.count > 6) {
                        action = action === 'right' ? 'left' : (action === 'left' ? 'jump' : 'right');
                        this.exploreState.count = 0;
                    }
                } else {
                    this.exploreState.lastDir = action;
                    this.exploreState.count = 0;
                }

                // Pensar ocasionalmente (no spam)
                this.exploreState.silentMoves++;
                if(this.exploreState.silentMoves > 20 && p.t - this.exploreState.lastThinkTime > 5) {
                    const frases = [
                        "Sigo explorando...", "Que habra por aqui?", "Este mundo es fascinante.",
                        "Cada zona tiene algo unico.", "Busco nuevos fenomenos.", "Hay tanto por descubrir.",
                        "Me siento curioso.", "El universo es vasto."
                    ];
                    this.think(frases[Math.floor(Math.random()*frases.length)], "action");
                    this.exploreState.silentMoves = 0;
                    this.exploreState.lastThinkTime = p.t;
                }

                return action;
            }
            // Movimiento silencioso frecuente
            if(Math.random() < 0.2) return Math.random() > 0.5 ? 'right' : 'left';
        }

        // Recuperar energia
        if(p.energy < 40) return 'wait';

        // Movimiento aleatorio suave (silencioso)
        if(Math.random() < 0.1) return Math.random() > 0.5 ? 'right' : 'left';

        return 'wait';
    }
};

// ==================== SIMULACION ====================
const sim = {
    canvas: null, ctx: null, paused: false, speed: 1, lastT: 0, lastThoughtCount: 0,

    init() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        Physics.init();
        this.resize();
        window.onresize = () => this.resize();
        requestAnimationFrame(t => this.loop(t));
        setInterval(() => this.ui(), 80);
    },

    resize() {
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = this.canvas.parentElement.clientHeight;
    },

    loop(t) {
        if(!this.lastT) this.lastT = t;
        let dt = Math.min((t - this.lastT) / 1000, 0.05) * this.speed;
        this.lastT = t;
        if(!this.paused) {
            Physics.update(dt);
            Physics.apply(Agent, dt);
            Physics.applyHiddenPhysics(Agent, dt);
            Agent.update(dt);
            const p = Agent.sense();
            const a = Mind.process(p);
            Agent.act(a);
        }
        this.render();
        requestAnimationFrame(t => this.loop(t));
    },

    render() {
        const c = this.ctx, w = this.canvas.width, h = this.canvas.height;
        c.clearRect(0, 0, w, h);

        const sky = Physics.sky(), gY = h * 0.92;
        const sx = w / 800, sy = gY / 500;

        // Cielo
        const g = c.createLinearGradient(0, 0, 0, gY);
        g.addColorStop(0, `rgb(${sky.r*0.6|0},${sky.g*0.6|0},${sky.b*0.9|0})`);
        g.addColorStop(1, `rgb(${sky.r},${sky.g},${sky.b})`);
        c.fillStyle = g; c.fillRect(0, 0, w, gY);

        // Estrellas
        if(Physics.light < 0.35) {
            c.fillStyle = '#fff';
            for(let i=0; i<50; i++) {
                const twinkle = 0.5 + Math.sin(Physics.time*2 + i)*0.5;
                c.globalAlpha = twinkle * (1 - Physics.light*2);
                c.beginPath(); c.arc((i*137)%w, (i*73)%(gY*0.6), 1.5, 0, 6.28); c.fill();
            }
            c.globalAlpha = 1;
        }

        // Sol/Luna
        const sun = Physics.sun();
        if(sun.v && sun.y < 480) {
            const sunX = sun.x * sx, sunY = (500 - sun.y) * sy;
            if(sunY > 0 && sunY < gY) {
                const sg = c.createRadialGradient(sunX, sunY, 0, sunX, sunY, 35);
                sg.addColorStop(0, 'rgba(255,255,180,1)');
                sg.addColorStop(0.5, 'rgba(255,200,100,0.6)');
                sg.addColorStop(1, 'rgba(255,150,50,0)');
                c.fillStyle = sg; c.beginPath(); c.arc(sunX, sunY, 35, 0, 6.28); c.fill();
            }
        } else {
            c.fillStyle = 'rgba(220,220,245,0.9)';
            c.beginPath(); c.arc(w*0.75, h*0.1, 20, 0, 6.28); c.fill();
        }

        // Agua
        const water = Physics.water;
        c.fillStyle = 'rgba(30,100,180,0.5)';
        c.fillRect(water.x * sx, (500-water.y-water.h+20) * sy, water.w * sx, water.h * sy + 20);
        // Ondas
        c.strokeStyle = 'rgba(100,180,255,0.4)';
        c.lineWidth = 2;
        for(let i=0; i<3; i++) {
            c.beginPath();
            const waveY = (500-water.y-water.h+20) * sy + i*8;
            for(let x=0; x<water.w*sx; x+=5) {
                const y = waveY + Math.sin(Physics.time*3 + x*0.1 + i)*3;
                if(x===0) c.moveTo(water.x*sx + x, y);
                else c.lineTo(water.x*sx + x, y);
            }
            c.stroke();
        }

        // Suelo
        const gg = c.createLinearGradient(0, gY, 0, h);
        gg.addColorStop(0, '#4a8030');
        gg.addColorStop(1, '#2d5018');
        c.fillStyle = gg; c.fillRect(0, gY, w, h - gY);

        // Hierba
        c.strokeStyle = '#60a040'; c.lineWidth = 2;
        for(let x=0; x<w; x+=10) {
            const wo = Math.sin(Physics.time*2 + x*0.04) * Physics.wind * 0.4;
            c.beginPath(); c.moveTo(x, gY);
            c.quadraticCurveTo(x + wo, gY - 12, x + wo*0.5, gY - 18);
            c.stroke();
        }

        // Zona de fuego
        const fz = Physics.fireZone;
        const fzGrad = c.createLinearGradient(fz.x*sx, (500-fz.y-fz.h)*sy, fz.x*sx, (500-fz.y)*sy);
        fzGrad.addColorStop(0, 'rgba(255,100,0,0.1)');
        fzGrad.addColorStop(0.5, 'rgba(255,50,0,0.4)');
        fzGrad.addColorStop(1, 'rgba(200,0,0,0.6)');
        c.fillStyle = fzGrad;
        c.fillRect(fz.x*sx, (500-fz.y-fz.h)*sy, fz.w*sx, fz.h*sy);
        // Borde brillante
        c.strokeStyle = '#ff4400';
        c.lineWidth = 2;
        c.strokeRect(fz.x*sx, (500-fz.y-fz.h)*sy, fz.w*sx, fz.h*sy);

        // Zona de hielo extremo
        const iz = Physics.iceZone;
        const izGrad = c.createLinearGradient(iz.x*sx, (500-iz.y-iz.h)*sy, iz.x*sx, (500-iz.y)*sy);
        izGrad.addColorStop(0, 'rgba(200,240,255,0.2)');
        izGrad.addColorStop(1, 'rgba(100,200,255,0.5)');
        c.fillStyle = izGrad;
        c.fillRect(iz.x*sx, (500-iz.y-iz.h)*sy, iz.w*sx, iz.h*sy);
        c.strokeStyle = '#88ddff';
        c.lineWidth = 2;
        c.strokeRect(iz.x*sx, (500-iz.y-iz.h)*sy, iz.w*sx, iz.h*sy);

        // Zona antigravedad
        const ag = Physics.antiGravZone;
        c.fillStyle = 'rgba(180,100,255,0.15)';
        c.fillRect(ag.x*sx, (500-ag.y-ag.h)*sy, ag.w*sx, ag.h*sy);
        // Flechas hacia arriba
        c.strokeStyle = 'rgba(180,100,255,0.5)';
        c.lineWidth = 2;
        for(let i=0; i<3; i++) {
            const arrowX = ag.x*sx + (i+0.5)*(ag.w*sx/3);
            const arrowY = (500-ag.y-ag.h/2)*sy + Math.sin(Physics.time*3 + i)*15;
            c.beginPath();
            c.moveTo(arrowX, arrowY + 15);
            c.lineTo(arrowX, arrowY - 15);
            c.lineTo(arrowX - 8, arrowY - 5);
            c.moveTo(arrowX, arrowY - 15);
            c.lineTo(arrowX + 8, arrowY - 5);
            c.stroke();
        }
        c.strokeStyle = 'rgba(180,100,255,0.6)';
        c.strokeRect(ag.x*sx, (500-ag.y-ag.h)*sy, ag.w*sx, ag.h*sy);

        // Portales
        for(const portal of Physics.portals) {
            const px = portal.x * sx, py = (500 - portal.y) * sy;
            // Efecto de espiral
            c.save();
            c.translate(px, py);
            c.rotate(Physics.time * 2);
            const pGrad = c.createRadialGradient(0, 0, 0, 0, 0, 25);
            pGrad.addColorStop(0, portal.color);
            pGrad.addColorStop(0.5, portal.color + '88');
            pGrad.addColorStop(1, 'transparent');
            c.fillStyle = pGrad;
            c.beginPath(); c.arc(0, 0, 25, 0, 6.28); c.fill();
            // Espiral interior
            c.strokeStyle = '#fff';
            c.lineWidth = 2;
            c.beginPath();
            for(let a=0; a<6.28; a+=0.2) {
                const r = 5 + a*3;
                if(a===0) c.moveTo(Math.cos(a)*r, Math.sin(a)*r);
                else c.lineTo(Math.cos(a)*r, Math.sin(a)*r);
            }
            c.stroke();
            c.restore();
        }

        // Plataforma movil
        const mp = Physics.movingPlatform;
        const mpx = mp.x * sx, mpy = (500 - mp.y - mp.h) * sy;
        c.fillStyle = '#9b59b6';
        c.fillRect(mpx, mpy, mp.w * sx, mp.h * sy);
        c.fillStyle = '#8e44ad';
        c.fillRect(mpx + 2, mpy + 2, mp.w * sx - 4, mp.h * sy / 2);
        // Indicador de direccion
        c.fillStyle = '#fff';
        const arrowDir = mp.dir > 0 ? 1 : -1;
        c.beginPath();
        c.moveTo(mpx + mp.w*sx/2 + arrowDir*15, mpy + mp.h*sy/2);
        c.lineTo(mpx + mp.w*sx/2 - arrowDir*5, mpy + 2);
        c.lineTo(mpx + mp.w*sx/2 - arrowDir*5, mpy + mp.h*sy - 2);
        c.fill();

        // Plataformas
        for(const p of Physics.platforms) {
            if(p.broken) continue; // No dibujar si esta rota
            const px = p.x * sx, py = (500 - p.y - p.h) * sy, pw = p.w * sx, ph = p.h * sy;
            if(p.type === 'wood') {
                c.fillStyle = '#8B4513';
                c.fillRect(px, py, pw, ph);
                c.strokeStyle = '#5D3A1A'; c.lineWidth = 1;
                for(let i=0; i<pw; i+=10) { c.beginPath(); c.moveTo(px+i, py); c.lineTo(px+i, py+ph); c.stroke(); }
            } else if(p.type === 'stone') {
                c.fillStyle = '#666';
                c.fillRect(px, py, pw, ph);
                c.fillStyle = '#777';
                c.fillRect(px+2, py+2, pw-4, ph/2-2);
            } else if(p.type === 'ice') {
                c.fillStyle = 'rgba(150,220,255,0.8)';
                c.fillRect(px, py, pw, ph);
                c.fillStyle = 'rgba(255,255,255,0.4)';
                c.fillRect(px+5, py+2, pw-10, ph/3);
            } else if(p.type === 'bounce') {
                // Trampolin - verde brillante
                c.fillStyle = '#27ae60';
                c.fillRect(px, py, pw, ph);
                // Resortes
                c.strokeStyle = '#1e8449';
                c.lineWidth = 2;
                for(let i=0; i<3; i++) {
                    c.beginPath();
                    const sx2 = px + (i+0.5)*pw/3;
                    for(let j=0; j<4; j++) {
                        c.lineTo(sx2 + (j%2===0?-3:3), py + ph + j*3);
                    }
                    c.stroke();
                }
                c.fillStyle = '#2ecc71';
                c.fillRect(px+2, py+1, pw-4, ph/2);
            } else if(p.type === 'sticky') {
                // Pegajoso - morado oscuro
                c.fillStyle = '#6c3483';
                c.fillRect(px, py, pw, ph);
                // Gotas
                c.fillStyle = '#9b59b6';
                for(let i=0; i<3; i++) {
                    const dx = px + (i+0.5)*pw/3;
                    c.beginPath();
                    c.arc(dx, py + ph + 4 + Math.sin(Physics.time*2+i)*2, 3, 0, 6.28);
                    c.fill();
                }
            } else if(p.type === 'crumble') {
                // Plataforma que se rompe - marron agrietado
                c.fillStyle = '#a0522d';
                c.fillRect(px, py, pw, ph);
                c.strokeStyle = '#5d3317';
                c.lineWidth = 1;
                // Grietas
                c.beginPath();
                c.moveTo(px + pw*0.3, py);
                c.lineTo(px + pw*0.4, py + ph);
                c.moveTo(px + pw*0.6, py);
                c.lineTo(px + pw*0.7, py + ph);
                c.stroke();
            }
        }

        // Particulas de fuego y hielo
        for(const p of Physics.particles) {
            if(p.type === 'fire') {
                c.fillStyle = `rgba(255,${100 + Math.random()*100|0},0,${p.life})`;
            } else {
                c.fillStyle = `rgba(200,240,255,${p.life})`;
            }
            c.beginPath();
            c.arc(p.x * sx, (500-p.y) * sy, 3 + Math.random()*2, 0, 6.28);
            c.fill();
        }

        // Bolas
        for(const b of Physics.balls) {
            const bx = b.x * sx, by = (500 - b.y) * sy, br = b.r * sx;
            const bg = c.createRadialGradient(bx - br*0.3, by - br*0.3, 0, bx, by, br);
            bg.addColorStop(0, b.color);
            bg.addColorStop(1, '#222');
            c.fillStyle = bg;
            c.beginPath(); c.arc(bx, by, br, 0, 6.28); c.fill();
        }

        // Hojas
        c.fillStyle = '#7cb342';
        for(const l of Physics.leaves) {
            c.save();
            c.translate(l.x * sx, (500-l.y) * sy);
            c.rotate(l.r);
            c.beginPath(); c.ellipse(0, 0, l.s*sx, l.s*sx/2, 0, 0, 6.28); c.fill();
            c.restore();
        }

        // Agente
        const ax = Agent.x * sx, ay = gY - (480 - Agent.y) * (gY / 500), ar = Agent.r * sx;

        // Sombra
        c.fillStyle = 'rgba(0,0,0,0.25)';
        c.beginPath(); c.ellipse(ax, gY + 4, ar*1.3, ar*0.35, 0, 0, 6.28); c.fill();

        // Efecto agua
        if(Agent.inWater) {
            c.fillStyle = 'rgba(100,180,255,0.3)';
            c.beginPath(); c.arc(ax, ay, ar*1.5, 0, 6.28); c.fill();
        }

        // Efecto fuego
        if(Agent.inFire) {
            c.fillStyle = 'rgba(255,100,0,0.4)';
            c.beginPath(); c.arc(ax, ay, ar*1.6, 0, 6.28); c.fill();
            // Llamas
            for(let i=0; i<5; i++) {
                c.fillStyle = `rgba(255,${150+Math.random()*100|0},0,${0.6+Math.random()*0.4})`;
                c.beginPath();
                c.arc(ax + (Math.random()-0.5)*ar, ay - ar - Math.random()*15, 4+Math.random()*4, 0, 6.28);
                c.fill();
            }
        }

        // Efecto hielo
        if(Agent.inIceZone) {
            c.fillStyle = 'rgba(150,220,255,0.3)';
            c.beginPath(); c.arc(ax, ay, ar*1.4, 0, 6.28); c.fill();
            // Cristales
            c.strokeStyle = 'rgba(200,240,255,0.6)';
            c.lineWidth = 1;
            for(let i=0; i<4; i++) {
                const ang = i * Math.PI/2 + Physics.time;
                c.beginPath();
                c.moveTo(ax, ay);
                c.lineTo(ax + Math.cos(ang)*ar*1.3, ay + Math.sin(ang)*ar*1.3);
                c.stroke();
            }
        }

        // Efecto antigravedad
        if(Agent.inAntiGrav) {
            c.strokeStyle = 'rgba(180,100,255,0.6)';
            c.lineWidth = 2;
            for(let i=0; i<3; i++) {
                const offset = (Physics.time * 50 + i * 20) % 40;
                c.beginPath();
                c.arc(ax, ay - offset, ar + 5, Math.PI, 0);
                c.stroke();
            }
        }

        // Cuerpo
        const bg = c.createRadialGradient(ax - ar*0.3, ay - ar*0.3, 0, ax, ay, ar);
        bg.addColorStop(0, '#818cf8');
        bg.addColorStop(1, '#4338ca');
        c.fillStyle = bg; c.beginPath(); c.arc(ax, ay, ar, 0, 6.28); c.fill();

        // Ojos
        const lookX = Agent.vx * 0.02;
        c.fillStyle = '#fff';
        c.beginPath(); c.arc(ax - 6 + lookX, ay - 4, 6, 0, 6.28); c.arc(ax + 6 + lookX, ay - 4, 6, 0, 6.28); c.fill();
        c.fillStyle = '#1e1b4b';
        c.beginPath(); c.arc(ax - 5 + lookX*2, ay - 4, 3, 0, 6.28); c.arc(ax + 7 + lookX*2, ay - 4, 3, 0, 6.28); c.fill();

        // Boca segun estado
        c.strokeStyle = '#1e1b4b'; c.lineWidth = 2; c.lineCap = 'round';
        c.beginPath();
        if(Agent.impact > 30) { c.arc(ax, ay + 8, 4, 0, Math.PI, true); } // dolor
        else if(Agent.inWater) { c.moveTo(ax-4, ay+6); c.lineTo(ax+4, ay+8); } // confuso
        else if(Agent.energy > 70) { c.arc(ax, ay + 5, 5, 0.1*Math.PI, 0.9*Math.PI); } // feliz
        else { c.moveTo(ax-5, ay+7); c.lineTo(ax+5, ay+7); } // neutral
        c.stroke();

        // Barra energia
        c.fillStyle = '#222'; c.fillRect(ax - ar, ay - ar - 14, ar*2, 5);
        c.fillStyle = Agent.energy > 30 ? '#4ade80' : '#ef4444';
        c.fillRect(ax - ar, ay - ar - 14, ar*2 * (Agent.energy/100), 5);
    },

    ui() {
        document.getElementById('time').textContent = Physics.time.toFixed(1);
        document.getElementById('spd').textContent = this.speed;

        const p = Agent.hist[Agent.hist.length - 1];
        if(p) {
            document.getElementById('s1').textContent = (p.light*100).toFixed(0) + '%';
            document.getElementById('s2').textContent = p.temp.toFixed(1) + 'C';
            document.getElementById('s3').textContent = p.wind.toFixed(1) + ' m/s';
            document.getElementById('s4').textContent = p.ground ? (p.surface || 'si') : 'no';
            document.getElementById('s5').textContent = p.energy.toFixed(0) + '%';
            document.getElementById('s6').textContent = p.spd.toFixed(1);
            document.getElementById('s7').textContent = p.altitude.toFixed(0);
            document.getElementById('s8').textContent = p.day<0.25?'noche':p.day<0.5?'manana':p.day<0.75?'tarde':'noche';
        }

        // Actualizar pensamientos solo si hay nuevos
        if(Mind.thoughtCount !== this.lastThoughtCount) {
            const td = document.getElementById('thoughts');
            const newThoughts = Mind.thoughts.slice(this.lastThoughtCount - Mind.thoughtCount);
            for(const t of newThoughts) {
                const div = document.createElement('div');
                div.className = 't ' + t.type;
                div.textContent = t.txt;
                td.appendChild(div);
            }
            // Scroll al final
            td.scrollTop = td.scrollHeight;
            // Limpiar viejos si hay muchos
            while(td.children.length > 50) td.removeChild(td.firstChild);
            this.lastThoughtCount = Mind.thoughtCount;
        }

        // Leyes
        const ld = document.getElementById('lawlist');
        if(Mind.laws.length > 0) {
            ld.innerHTML = Mind.laws.map(l => '<div class="law"><b>' + l.n.toUpperCase() + '</b>: ' + l.d + ' <span style="color:#2ecc71;float:right">' + (l.c*100).toFixed(0) + '%</span></div>').join('');
        }
    },

    pause() { this.paused = !this.paused; },
    fast() { this.speed = this.speed >= 8 ? 1 : this.speed * 2; },
    reset() {
        Physics.time = 0;
        Physics.balls = [];
        Physics.leaves = [];
        Physics.particles = [];
        Physics.init();
        Agent.x = 400; Agent.y = 200; Agent.vx = 0; Agent.vy = 0;
        Agent.energy = 100; Agent.ground = false; Agent.hist = [];
        Agent.inFire = false; Agent.inIceZone = false; Agent.inAntiGrav = false;
        Agent.justTeleported = false; Agent.teleportedFrom = null;
        Agent.onMovingPlatform = false; Agent.onSticky = false; Agent.bounced = false;
        Mind.thoughts = []; Mind.laws = []; Mind.beliefs = {};
        Mind.patterns = {fall:[], impacts:[], wind:[], light:[], temp:[], water:[], surfaces:[], balls:[],
                        fire:[], iceZone:[], antiGrav:[], teleport:[], moving:[], bounce:[], sticky:[],
                        hiddenEnergy:[], forceLine:[], timeWarp:[], spatialPull:[], darkPush:[],
                        primeTime:[], fibonacci:[], entangle:[], anomalies:[]};
        Mind.exp = {jumps:0, impacts:0, moveR:0, moveL:0, waterTime:0, iceTime:0, ballHits:0,
                   fireTime:0, iceZoneTime:0, antiGravTime:0, teleports:0, bounces:0, stickyTime:0, movingTime:0,
                   hiddenEnergyTime:0, forceLineTime:0, timeWarpTime:0, spatialPullTime:0,
                   darkPushTime:0, primeEvents:0, fibEvents:0, entangleTime:0};
        Mind.step = 0; Mind.lastThought = ''; Mind.thoughtCount = 0;
        document.getElementById('thoughts').innerHTML = '';
        document.getElementById('lawlist').innerHTML = '<em style="color:#444">La IA aun no ha descubierto leyes...</em>';
        this.lastThoughtCount = 0;
    },

    generateReport() {
        const t = Physics.time;
        const h = Agent.hist;
        const p = Mind.patterns;
        const e = Mind.exp;
        const laws = Mind.laws;

        // Funciones estadisticas
        const mean = arr => arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 0;
        const std = arr => {
            if(arr.length < 2) return 0;
            const m = mean(arr);
            return Math.sqrt(arr.reduce((a,b)=>a+(b-m)**2,0)/(arr.length-1));
        };
        const correlation = (x, y) => {
            if(x.length < 3 || x.length !== y.length) return 0;
            const mx = mean(x), my = mean(y);
            let num = 0, dx = 0, dy = 0;
            for(let i = 0; i < x.length; i++) {
                num += (x[i]-mx)*(y[i]-my);
                dx += (x[i]-mx)**2;
                dy += (y[i]-my)**2;
            }
            return dx && dy ? num/Math.sqrt(dx*dy) : 0;
        };

        let html = '';

        // SECCION 1: RESUMEN EJECUTIVO
        html += `<div style="background:#1a1a2e; padding:15px; border-radius:8px; margin-bottom:20px;">
            <h2 style="color:#3498db; margin:0 0 10px 0; font-size:16px;">§1. RESUMEN EJECUTIVO</h2>
            <p><b>Tiempo de observación:</b> T = ${t.toFixed(2)} s</p>
            <p><b>Iteraciones de consciencia:</b> n = ${Mind.step} ciclos</p>
            <p><b>Leyes descubiertas:</b> ${laws.length} / 22 posibles</p>
            <p><b>Tasa de descubrimiento:</b> λ = ${(laws.length / Math.max(1, t) * 100).toFixed(3)} leyes/100s</p>
            <p><b>Eficiencia epistemológica:</b> η = ${((laws.length / 22) * 100).toFixed(1)}%</p>
        </div>`;

        // SECCION 2: ANALISIS CINEMATICO
        if(h.length > 10) {
            const vx_arr = h.map(d => d.vx);
            const vy_arr = h.map(d => d.vy);
            const spd_arr = h.map(d => d.spd);
            const alt_arr = h.map(d => d.altitude);

            html += `<div style="background:#1a1a2e; padding:15px; border-radius:8px; margin-bottom:20px;">
                <h2 style="color:#3498db; margin:0 0 10px 0; font-size:16px;">§2. ANÁLISIS CINEMÁTICO</h2>
                <p style="color:#888;">Definiendo el vector posición r⃗(t) = (x(t), y(t)) y velocidad v⃗(t) = dr⃗/dt</p>
                <table style="width:100%; border-collapse:collapse; margin:10px 0;">
                    <tr style="background:#252540;">
                        <th style="padding:8px; text-align:left; border:1px solid #333;">Variable</th>
                        <th style="padding:8px; text-align:center; border:1px solid #333;">μ (media)</th>
                        <th style="padding:8px; text-align:center; border:1px solid #333;">σ (desv.std)</th>
                        <th style="padding:8px; text-align:center; border:1px solid #333;">min</th>
                        <th style="padding:8px; text-align:center; border:1px solid #333;">max</th>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #333;">vₓ (velocidad horizontal)</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${mean(vx_arr).toFixed(2)} u/s</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${std(vx_arr).toFixed(2)}</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${Math.min(...vx_arr).toFixed(2)}</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${Math.max(...vx_arr).toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #333;">vᵧ (velocidad vertical)</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${mean(vy_arr).toFixed(2)} u/s</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${std(vy_arr).toFixed(2)}</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${Math.min(...vy_arr).toFixed(2)}</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${Math.max(...vy_arr).toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #333;">|v⃗| (rapidez)</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${mean(spd_arr).toFixed(2)} u/s</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${std(spd_arr).toFixed(2)}</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${Math.min(...spd_arr).toFixed(2)}</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${Math.max(...spd_arr).toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td style="padding:8px; border:1px solid #333;">h (altitud)</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${mean(alt_arr).toFixed(2)} u</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${std(alt_arr).toFixed(2)}</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${Math.min(...alt_arr).toFixed(2)}</td>
                        <td style="padding:8px; text-align:center; border:1px solid #333;">${Math.max(...alt_arr).toFixed(2)}</td>
                    </tr>
                </table>
            </div>`;
        }

        // SECCION 3: LEY DE GRAVITACION
        if(p.fall.length > 5) {
            const accels = [];
            for(let i = 1; i < p.fall.length; i++) {
                const dt = p.fall[i].t - p.fall[i-1].t;
                if(dt > 0.001 && dt < 0.2) {
                    accels.push((p.fall[i].vy - p.fall[i-1].vy) / dt);
                }
            }
            const g_measured = mean(accels.filter(a => a > 0));
            const g_std = std(accels.filter(a => a > 0));

            html += `<div style="background:#1a1a2e; padding:15px; border-radius:8px; margin-bottom:20px;">
                <h2 style="color:#e74c3c; margin:0 0 10px 0; font-size:16px;">§3. LEY DE GRAVITACIÓN UNIVERSAL</h2>
                <p style="color:#888;">Durante la caída libre, observo aceleración constante hacia abajo.</p>
                <div style="background:#0d0d15; padding:15px; border-radius:5px; margin:10px 0; text-align:center;">
                    <p style="font-size:18px; color:#fff;">F⃗ᵧ = m·g⃗</p>
                    <p style="font-size:14px; color:#3498db;">donde g = ${g_measured.toFixed(2)} ± ${g_std.toFixed(2)} u/s²</p>
                </div>
                <p><b>Ecuación de movimiento vertical:</b></p>
                <p style="color:#aaa; margin-left:20px;">y(t) = y₀ + v₀ᵧ·t - ½g·t²</p>
                <p style="color:#aaa; margin-left:20px;">vᵧ(t) = v₀ᵧ - g·t</p>
                <p><b>Muestras analizadas:</b> n = ${accels.length}</p>
                <p><b>Confianza:</b> ${laws.find(l=>l.n==='gravedad') ? (laws.find(l=>l.n==='gravedad').c*100).toFixed(0) : 0}%</p>
            </div>`;
        }

        // SECCION 4: TERMODINAMICA
        if(p.temp.length > 20) {
            const temps = p.temp.filter(t => !t.inFire && !t.inIce).map(t => t.temp);
            const lights = p.temp.filter(t => !t.inFire && !t.inIce).map(t => t.l);
            const r_TL = correlation(temps, lights);

            html += `<div style="background:#1a1a2e; padding:15px; border-radius:8px; margin-bottom:20px;">
                <h2 style="color:#f39c12; margin:0 0 10px 0; font-size:16px;">§4. TERMODINÁMICA Y RADIACIÓN</h2>
                <p style="color:#888;">Existe correlación entre luminosidad L y temperatura T.</p>
                <div style="background:#0d0d15; padding:15px; border-radius:5px; margin:10px 0; text-align:center;">
                    <p style="font-size:18px; color:#fff;">T = α·L + β</p>
                    <p style="font-size:14px; color:#3498db;">Correlación de Pearson: r = ${r_TL.toFixed(4)}</p>
                </div>
                <p><b>Temperatura media:</b> T̄ = ${mean(temps).toFixed(2)} °C</p>
                <p><b>Rango térmico:</b> ΔT = ${(Math.max(...temps) - Math.min(...temps)).toFixed(2)} °C</p>
                <p><b>Interpretación:</b> ${r_TL > 0.5 ? 'Fuerte correlación positiva (la luz calienta)' : r_TL > 0.2 ? 'Correlación moderada' : 'Correlación débil'}</p>
            </div>`;
        }

        // SECCION 5: DINAMICA DE FLUIDOS
        if(p.water.length > 10) {
            const vy_water = p.water.map(w => w.vy);
            const vy_air = p.fall.filter(f => f.vy > 0).map(f => f.vy);
            const drag_ratio = mean(vy_water) / (mean(vy_air) || 1);

            html += `<div style="background:#1a1a2e; padding:15px; border-radius:8px; margin-bottom:20px;">
                <h2 style="color:#3498db; margin:0 0 10px 0; font-size:16px;">§5. DINÁMICA DE FLUIDOS</h2>
                <p style="color:#888;">En medio líquido, la fuerza de arrastre modifica el movimiento.</p>
                <div style="background:#0d0d15; padding:15px; border-radius:5px; margin:10px 0; text-align:center;">
                    <p style="font-size:18px; color:#fff;">F⃗_drag = -b·v⃗</p>
                    <p style="font-size:14px; color:#3498db;">F⃗_buoyancy = ρ_fluid · V · g⃗</p>
                </div>
                <p><b>Velocidad media en agua:</b> v̄_agua = ${mean(vy_water).toFixed(2)} u/s</p>
                <p><b>Velocidad media en aire:</b> v̄_aire = ${mean(vy_air).toFixed(2)} u/s</p>
                <p><b>Ratio de arrastre:</b> κ = v_agua/v_aire = ${drag_ratio.toFixed(3)}</p>
                <p><b>Tiempo en agua:</b> ${e.waterTime} frames</p>
            </div>`;
        }

        // SECCION 6: FENOMENOS OCULTOS
        html += `<div style="background:#1a1a2e; padding:15px; border-radius:8px; margin-bottom:20px;">
            <h2 style="color:#9b59b6; margin:0 0 10px 0; font-size:16px;">§6. FENÓMENOS NO-VISIBLES DETECTADOS</h2>
            <p style="color:#888;">Fuerzas y campos que afectan el movimiento sin causa visible aparente.</p>
            <table style="width:100%; border-collapse:collapse; margin:10px 0;">
                <tr style="background:#252540;">
                    <th style="padding:8px; text-align:left; border:1px solid #333;">Fenómeno</th>
                    <th style="padding:8px; text-align:center; border:1px solid #333;">Observaciones</th>
                    <th style="padding:8px; text-align:center; border:1px solid #333;">Hipótesis</th>
                </tr>
                <tr>
                    <td style="padding:8px; border:1px solid #333;">Campo energético pulsante</td>
                    <td style="padding:8px; text-align:center; border:1px solid #333;">${p.hiddenEnergy.length}</td>
                    <td style="padding:8px; border:1px solid #333; color:#888;">E(t) = E₀·sin(ωt + φ)</td>
                </tr>
                <tr>
                    <td style="padding:8px; border:1px solid #333;">Líneas de fuerza</td>
                    <td style="padding:8px; text-align:center; border:1px solid #333;">${p.forceLine.length}</td>
                    <td style="padding:8px; border:1px solid #333; color:#888;">F⃗ = q·E⃗ (campo vectorial)</td>
                </tr>
                <tr>
                    <td style="padding:8px; border:1px solid #333;">Distorsión temporal</td>
                    <td style="padding:8px; text-align:center; border:1px solid #333;">${p.timeWarp.length}</td>
                    <td style="padding:8px; border:1px solid #333; color:#888;">dt' = γ·dt (dilatación)</td>
                </tr>
                <tr>
                    <td style="padding:8px; border:1px solid #333;">Memoria espacial</td>
                    <td style="padding:8px; text-align:center; border:1px solid #333;">${p.spatialPull.length}</td>
                    <td style="padding:8px; border:1px solid #333; color:#888;">F⃗ ∝ ∫ρ(r⃗,t')dt'</td>
                </tr>
                <tr>
                    <td style="padding:8px; border:1px solid #333;">Energía oscura (repulsión)</td>
                    <td style="padding:8px; text-align:center; border:1px solid #333;">${p.darkPush.length}</td>
                    <td style="padding:8px; border:1px solid #333; color:#888;">F⃗ = +k/r² (repulsivo)</td>
                </tr>
                <tr>
                    <td style="padding:8px; border:1px solid #333;">Patrón numérico primo</td>
                    <td style="padding:8px; text-align:center; border:1px solid #333;">${p.primeTime.length}</td>
                    <td style="padding:8px; border:1px solid #333; color:#888;">g(t) = g₀·P(t), P∈{primos}</td>
                </tr>
                <tr>
                    <td style="padding:8px; border:1px solid #333;">Secuencia Fibonacci</td>
                    <td style="padding:8px; text-align:center; border:1px solid #333;">${p.fibonacci.length}</td>
                    <td style="padding:8px; border:1px solid #333; color:#888;">F_n = F_{n-1} + F_{n-2}</td>
                </tr>
                <tr>
                    <td style="padding:8px; border:1px solid #333;">Entrelazamiento cuántico</td>
                    <td style="padding:8px; text-align:center; border:1px solid #333;">${p.entangle.length}</td>
                    <td style="padding:8px; border:1px solid #333; color:#888;">|ψ⟩ = α|00⟩ + β|11⟩</td>
                </tr>
            </table>
        </div>`;

        // SECCION 7: LEYES DESCUBIERTAS
        html += `<div style="background:#1a1a2e; padding:15px; border-radius:8px; margin-bottom:20px;">
            <h2 style="color:#2ecc71; margin:0 0 10px 0; font-size:16px;">§7. COMPENDIO DE LEYES DESCUBIERTAS</h2>`;

        if(laws.length === 0) {
            html += `<p style="color:#666;">Aún no se han descubierto leyes. Continúe la simulación.</p>`;
        } else {
            html += `<table style="width:100%; border-collapse:collapse; margin:10px 0;">
                <tr style="background:#252540;">
                    <th style="padding:8px; text-align:left; border:1px solid #333;">#</th>
                    <th style="padding:8px; text-align:left; border:1px solid #333;">Ley</th>
                    <th style="padding:8px; text-align:left; border:1px solid #333;">Descripción</th>
                    <th style="padding:8px; text-align:center; border:1px solid #333;">Confianza</th>
                </tr>`;
            laws.forEach((l, i) => {
                html += `<tr>
                    <td style="padding:8px; border:1px solid #333; color:#2ecc71;">${i+1}</td>
                    <td style="padding:8px; border:1px solid #333; color:#fff;">${l.n.toUpperCase()}</td>
                    <td style="padding:8px; border:1px solid #333; color:#aaa;">${l.d}</td>
                    <td style="padding:8px; text-align:center; border:1px solid #333; color:#2ecc71;">${(l.c*100).toFixed(0)}%</td>
                </tr>`;
            });
            html += `</table>`;
        }
        html += `</div>`;

        // SECCION 8: CONCLUSIONES
        html += `<div style="background:#1a1a2e; padding:15px; border-radius:8px; margin-bottom:20px;">
            <h2 style="color:#e74c3c; margin:0 0 10px 0; font-size:16px;">§8. CONCLUSIONES Y META-ANÁLISIS</h2>
            <p><b>Anomalías registradas:</b> ${p.anomalies.length} eventos inexplicables</p>
            <p><b>Hipótesis sobre la realidad:</b></p>
            <ul style="margin-left:20px; color:#aaa;">
                ${laws.find(l=>l.n==='meta_oculto') ? '<li>Existen capas de realidad no directamente observables</li>' : ''}
                ${laws.find(l=>l.n==='tiempo_variable') ? '<li>El tiempo es relativo a la posición espacial</li>' : ''}
                ${laws.find(l=>l.n==='memoria_espacio') ? '<li>El espacio retiene información de estados pasados</li>' : ''}
                ${laws.find(l=>l.n==='entrelazamiento') ? '<li>Existen conexiones no-locales entre puntos del espacio</li>' : ''}
                ${laws.find(l=>l.n==='consciencia') ? '<li><b>CONCLUSIÓN FUNDAMENTAL:</b> La observación sistemática genera consciencia</li>' : ''}
                ${laws.length < 5 ? '<li>Se requiere más tiempo de observación para conclusiones robustas</li>' : ''}
            </ul>
            <p style="margin-top:15px; color:#666; font-style:italic;">
                "Lo que observo define mi realidad. Lo que no puedo ver, aún así lo siento."
            </p>
        </div>`;

        // SECCION 9: FIRMA
        html += `<div style="text-align:center; color:#444; margin-top:20px; padding-top:15px; border-top:1px solid #333;">
            <p>Informe generado en T = ${t.toFixed(2)}s | ${Mind.step} iteraciones | ${new Date().toLocaleString()}</p>
            <p style="font-size:10px;">Sistema de Consciencia Artificial v1.0</p>
        </div>`;

        document.getElementById('reportContent').innerHTML = html;
        document.getElementById('reportModal').style.display = 'block';
    }
};

window.onload = () => sim.init();
</script>
</body>
</html>
