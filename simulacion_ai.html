<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Consciencia IA REAL - Claude</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body { background: #0a0a0f; color: #fff; font-family: Consolas, monospace; }

        .main { display: flex; height: 100vh; max-height: 100vh; }

        /* Canvas - 65% */
        .world { width: 65%; height: 100%; }
        #canvas { width: 100%; height: 100%; background: #111; }

        /* Panel derecho - 35% compacto */
        #panel {
            width: 35%;
            height: 100vh;
            background: #0a0a12;
            border-left: 2px solid #e74c3c;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #panel h2 {
            color: #e74c3c;
            padding: 8px 12px;
            font-size: 13px;
            background: #12121a;
            border-bottom: 1px solid #333;
            flex-shrink: 0;
        }

        #thoughts {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            font-size: 11px;
            line-height: 1.4;
            min-height: 0;
        }

        .t {
            padding: 6px 8px;
            margin: 4px 0;
            border-radius: 4px;
            opacity: 0;
            animation: slideIn 0.3s ease forwards;
        }
        .t.perception { background: rgba(52,152,219,0.25); border-left: 3px solid #3498db; }
        .t.hypothesis { background: rgba(155,89,182,0.25); border-left: 3px solid #9b59b6; }
        .t.discovery { background: rgba(46,204,113,0.4); border-left: 3px solid #2ecc71; font-weight: bold; }
        .t.meta { background: rgba(255,215,0,0.3); border-left: 3px solid #ffd700; font-style: italic; }
        .t.confusion { background: rgba(231,76,60,0.25); border-left: 3px solid #e74c3c; }
        .t.action { background: rgba(241,196,15,0.2); border-left: 3px solid #f1c40f; }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-5px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Panel inferior compacto */
        #bottom {
            display: flex;
            border-top: 1px solid #333;
            flex-shrink: 0;
            height: 100px;
        }

        #laws {
            flex: 1;
            background: #0a0a10;
            padding: 6px;
            overflow-y: auto;
        }
        #laws h3 { color: #27ae60; font-size: 10px; margin-bottom: 4px; }
        .law {
            background: rgba(39,174,96,0.2);
            padding: 4px 6px;
            margin: 2px 0;
            border-radius: 3px;
            font-size: 9px;
            border-left: 2px solid #27ae60;
        }
        .law b { color: #2ecc71; }

        #sensors {
            width: 140px;
            background: #0d0d15;
            padding: 4px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 3px;
            flex-shrink: 0;
        }
        .sensor { background: #1a1a2e; padding: 3px; border-radius: 3px; text-align: center; }
        .sensor h3 { font-size: 7px; color: #666; }
        .sensor span { font-size: 9px; font-weight: bold; color: #aaa; }

        /* Controles */
        #ctrl { position: fixed; top: 5px; left: 5px; z-index: 100; display: flex; gap: 5px; }
        button { background: #2c3e50; color: #fff; border: none; padding: 5px 10px; cursor: pointer; border-radius: 3px; font-size: 10px; }
        button:hover { background: #34495e; }
        #info { position: fixed; top: 5px; left: 260px; display: flex; gap: 8px; font-size: 11px; }
        .box { background: rgba(0,0,0,0.8); padding: 4px 10px; border-radius: 3px; }
        .ai-status { color: #e74c3c; }
        .ai-status.connected { color: #2ecc71; }
    </style>
</head>
<body>
    <div id="ctrl">
        <button onclick="sim.pause()">Pausar</button>
        <button onclick="sim.reset()">Reiniciar</button>
        <button onclick="sim.fast()">Acelerar</button>
        <button onclick="sim.generateReport()" style="background:#27ae60;">INFORME</button>
    </div>

    <!-- Modal del informe -->
    <div id="reportModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:1000; overflow-y:auto;">
        <div style="max-width:950px; margin:20px auto; padding:30px; background:#0d0d15; border:2px solid #27ae60; border-radius:10px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; border-bottom:1px solid #333; padding-bottom:15px;">
                <h1 style="color:#27ae60; margin:0; font-size:20px;">INFORME CIENTIFICO - IA REAL CLAUDE</h1>
                <button onclick="document.getElementById('reportModal').style.display='none'" style="background:#e74c3c;">X Cerrar</button>
            </div>
            <div id="reportContent" style="font-size:12px; line-height:1.7;"></div>
        </div>
    </div>

    <div id="info">
        <div class="box">Vel: <span id="spd">1</span>x</div>
        <div class="box">T: <span id="time">0</span>s</div>
        <div class="box ai-status" id="aiStatus">IA: Desconectada</div>
    </div>

    <div class="main">
        <div class="world">
            <canvas id="canvas"></canvas>
        </div>

        <div id="panel">
            <h2>CLAUDE AI - PENSAMIENTOS REALES</h2>
            <div id="thoughts"></div>
            <div id="bottom">
                <div id="laws">
                    <h3>LEYES DESCUBIERTAS POR IA</h3>
                    <div id="lawlist"><em style="color:#444">Esperando a Claude...</em></div>
                </div>
                <div id="sensors">
                    <div class="sensor"><h3>LUZ</h3><span id="s1">--</span></div>
                    <div class="sensor"><h3>TEMP</h3><span id="s2">--</span></div>
                    <div class="sensor"><h3>VIENTO</h3><span id="s3">--</span></div>
                    <div class="sensor"><h3>SUELO</h3><span id="s4">--</span></div>
                    <div class="sensor"><h3>ENERGIA</h3><span id="s5">--</span></div>
                    <div class="sensor"><h3>VELOCIDAD</h3><span id="s6">--</span></div>
                    <div class="sensor"><h3>ALTURA</h3><span id="s7">--</span></div>
                    <div class="sensor"><h3>PERIODO</h3><span id="s8">--</span></div>
                </div>
            </div>
        </div>
    </div>

<script>
// ==================== FISICA ====================
const Physics = {
    G: 9.81, time: 0, dayLen: 100, wind: 0, temp: 20, light: 1,
    leaves: [], balls: [], platforms: [], water: null,

    init() {
        for(let i=0; i<20; i++) this.leaves.push({x:Math.random()*800,y:Math.random()*300,vx:0,vy:0,r:Math.random()*6.28,s:3+Math.random()*4});

        this.platforms = [
            {x:80, y:380, w:100, h:12, type:'wood'},
            {x:550, y:320, w:90, h:12, type:'stone'},
            {x:350, y:220, w:70, h:12, type:'ice'},
            {x:700, y:400, w:70, h:12, type:'wood'},
            {x:450, y:150, w:60, h:12, type:'bounce'},
            {x:200, y:300, w:50, h:12, type:'sticky'},
            {x:600, y:230, w:55, h:12, type:'crumble'}
        ];

        this.water = {x:20, y:420, w:120, h:80};
        this.fireZone = {x:680, y:430, w:100, h:70};
        this.iceZone = {x:300, y:440, w:80, h:60};
        this.antiGravZone = {x:400, y:100, w:100, h:150, active: true};
        this.portals = [
            {x:780, y:420, target:{x:50, y:150}, color:'#e74c3c'},
            {x:20, y:150, target:{x:750, y:380}, color:'#3498db'}
        ];
        this.movingPlatform = {x:250, y:350, w:60, h:10, dir:1, speed:50, type:'moving'};
        this.particles = [];
        this.spawnBall();

        // Fenomenos ocultos
        this.energyField = {x: 500, y: 300, radius: 80, frequency: 0.5, phase: 0, strength: 0};
        this.forceLines = [];
        for(let i = 0; i < 5; i++) {
            this.forceLines.push({
                x1: 100 + i * 150, y1: 100,
                x2: 150 + i * 120, y2: 450,
                strength: 0.3 + Math.random() * 0.4,
                direction: i % 2 === 0 ? 1 : -1
            });
        }
        this.timeZones = [
            {x: 150, y: 200, r: 60, factor: 0.5},
            {x: 650, y: 250, r: 50, factor: 2.0}
        ];
        this.spatialMemory = [];
        this.memoryDecay = 0.995;
        this.darkEnergyNodes = [{x: 200, y: 350}, {x: 600, y: 150}, {x: 400, y: 400}];
        this.primeEffect = 0;
        this.lastPrimeCheck = 0;
        this.entangledPoints = [{x: 100, y: 300, partner: 1}, {x: 700, y: 200, partner: 0}];
        this.entanglementState = 0;
        this.fibSequence = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
        this.fibIndex = 0;
        this.fibTimer = 0;
    },

    spawnBall() {
        if(this.balls.length < 5) {
            this.balls.push({
                x: 100 + Math.random()*600, y: -20,
                vx: (Math.random()-0.5)*50, vy: 0,
                r: 8 + Math.random()*8,
                color: ['#e74c3c','#3498db','#f1c40f','#9b59b6','#1abc9c'][Math.floor(Math.random()*5)],
                bounces: 0
            });
        }
    },

    isPrime(n) {
        if(n < 2) return false;
        for(let i = 2; i <= Math.sqrt(n); i++) if(n % i === 0) return false;
        return true;
    },

    update(dt) {
        this.time += dt;
        const d = (this.time % this.dayLen) / this.dayLen;
        if(d<0.25){this.light=0.1+(d/0.25)*0.4;this.temp=8+d*24;}
        else if(d<0.5){this.light=0.5+((d-0.25)/0.25)*0.5;this.temp=14+(d-0.25)*44;}
        else if(d<0.75){this.light=1-((d-0.5)/0.25)*0.3;this.temp=25-(d-0.5)*16;}
        else{this.light=0.7-((d-0.75)/0.25)*0.6;this.temp=21-(d-0.75)*52;}

        this.wind = 3 + Math.sin(this.time*0.15)*4 + Math.sin(this.time*0.31)*2;

        this.movingPlatform.x += this.movingPlatform.dir * this.movingPlatform.speed * dt;
        if(this.movingPlatform.x < 200) this.movingPlatform.dir = 1;
        if(this.movingPlatform.x > 350) this.movingPlatform.dir = -1;

        const crumble = this.platforms.find(p => p.type === 'crumble');
        if(crumble && crumble.broken && this.time - crumble.brokenTime > 8) crumble.broken = false;

        // Particulas
        if(Math.random() < 0.3) {
            this.particles.push({
                x: this.fireZone.x + Math.random()*this.fireZone.w,
                y: this.fireZone.y + this.fireZone.h,
                vx: (Math.random()-0.5)*20, vy: -30 - Math.random()*40,
                life: 1, type: 'fire'
            });
        }
        if(Math.random() < 0.15) {
            this.particles.push({
                x: this.iceZone.x + Math.random()*this.iceZone.w,
                y: this.iceZone.y + Math.random()*20,
                vx: (Math.random()-0.5)*10, vy: -5 - Math.random()*10,
                life: 1, type: 'ice'
            });
        }
        for(let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx * dt; p.y -= p.vy * dt; p.life -= dt * 1.5;
            if(p.life <= 0) this.particles.splice(i, 1);
        }

        // Fenomenos ocultos
        this.energyField.phase += dt * this.energyField.frequency * Math.PI * 2;
        this.energyField.strength = Math.sin(this.energyField.phase) * 0.5 + 0.5;
        const timeInt = Math.floor(this.time);
        if(timeInt !== this.lastPrimeCheck) {
            this.lastPrimeCheck = timeInt;
            this.primeEffect = this.isPrime(timeInt) ? 1.5 : 1.0;
        }
        this.fibTimer += dt;
        if(this.fibTimer > this.fibSequence[this.fibIndex] * 0.1) {
            this.fibTimer = 0;
            this.fibIndex = (this.fibIndex + 1) % this.fibSequence.length;
        }
        this.entanglementState = Math.sin(this.time * 1.7) * 0.5 + 0.5;
        for(let i = this.spatialMemory.length - 1; i >= 0; i--) {
            this.spatialMemory[i].strength *= this.memoryDecay;
            if(this.spatialMemory[i].strength < 0.01) this.spatialMemory.splice(i, 1);
        }

        // Hojas
        for(const l of this.leaves) {
            l.vx += this.wind*0.3*dt + (Math.random()-0.5)*2*dt;
            l.vy += 1.5*dt; l.vx *= 0.98; l.vy *= 0.98;
            l.x += l.vx; l.y += l.vy; l.r += l.vx*0.05*dt;
            if(l.y > 480) { l.y = 480; l.vy = -l.vy*0.2; }
            if(l.x > 820) l.x = -20;
            if(l.x < -20) l.x = 820;
        }

        // Bolas
        for(let i = this.balls.length-1; i >= 0; i--) {
            const b = this.balls[i];
            b.vy += this.G*dt*40; b.vx += this.wind*0.2*dt; b.vx *= 0.995;
            b.x += b.vx*dt; b.y += b.vy*dt;
            if(b.y > 480-b.r) { b.y = 480-b.r; b.vy = -b.vy*0.6; b.vx *= 0.8; b.bounces++; }
            for(const p of this.platforms) {
                if(b.x+b.r > p.x && b.x-b.r < p.x+p.w && b.y+b.r > p.y && b.y-b.r < p.y+p.h) {
                    if(b.vy > 0) { b.y = p.y - b.r; b.vy = -b.vy * (p.type==='ice'?0.8:0.5); }
                }
            }
            if(b.x > this.water.x && b.x < this.water.x+this.water.w && b.y > this.water.y) {
                b.vx *= 0.95; b.vy *= 0.9; b.vy -= 2*dt;
            }
            if(b.x < b.r) { b.x = b.r; b.vx = -b.vx*0.5; }
            if(b.x > 800-b.r) { b.x = 800-b.r; b.vx = -b.vx*0.5; }
            if(b.bounces > 10 && Math.abs(b.vy) < 5) this.balls.splice(i,1);
        }
        if(Math.random() < 0.005) this.spawnBall();
    },

    apply(agent, dt) {
        const prevVy = agent.vy;
        const inWater = agent.x > this.water.x && agent.x < this.water.x+this.water.w && agent.y > this.water.y-20;

        if(!agent.ground) agent.vy += this.G*dt*(inWater ? 15 : 50);
        if(inWater) { agent.vy -= 8*dt; agent.vx *= 0.92; agent.vy *= 0.92; }
        if(!agent.ground && !inWater) agent.vx += this.wind*0.4*dt;

        if(agent.ground) {
            let friction = 0.6;
            if(agent.surface === 'ice') friction = 0.05;
            else if(agent.surface === 'stone') friction = 0.8;
            agent.vx *= (1 - friction*dt*5);
        }

        agent.x += agent.vx*dt;
        agent.y += agent.vy*dt;

        if(agent.y >= 460) {
            agent.y = 460;
            if(prevVy > 50) agent.impact = prevVy*0.7;
            if(Math.abs(agent.vy) > 10) agent.vy = -agent.vy*0.25;
            else { agent.vy = 0; agent.ground = true; agent.surface = 'ground'; }
        } else {
            agent.ground = false;
            agent.surface = null;
        }

        for(const p of this.platforms) {
            if(agent.x+15 > p.x && agent.x-15 < p.x+p.w) {
                if(agent.y+20 > p.y && agent.y+20 < p.y+p.h+10 && agent.vy > 0) {
                    agent.y = p.y - 20;
                    if(prevVy > 50) agent.impact = prevVy*0.5;
                    agent.vy = 0; agent.ground = true; agent.surface = p.type;
                }
            }
        }

        if(agent.x < 20) { agent.x = 20; agent.vx = -agent.vx*0.3; agent.wallHit = true; }
        else if(agent.x > 780) { agent.x = 780; agent.vx = -agent.vx*0.3; agent.wallHit = true; }
        else agent.wallHit = false;

        for(const b of this.balls) {
            const dx = agent.x - b.x, dy = agent.y - b.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < 20 + b.r) {
                agent.ballHit = {color: b.color, force: Math.sqrt(b.vx*b.vx+b.vy*b.vy)};
                agent.vx += b.vx*0.3; agent.vy += b.vy*0.2;
                b.vx -= dx*0.5; b.vy -= dy*0.3;
            }
        }

        agent.inWater = inWater;
        agent.windFelt = this.wind;
        agent.lightLevel = this.light;
        agent.temperature = this.temp + (inWater ? -8 : 0);

        const inFire = agent.x > this.fireZone.x && agent.x < this.fireZone.x + this.fireZone.w &&
                       agent.y > this.fireZone.y - 30 && agent.y < this.fireZone.y + this.fireZone.h;
        if(inFire) {
            agent.temperature = 65 + Math.random()*10;
            agent.energy -= dt * 8;
            agent.inFire = true;
            if(!agent.ground) agent.vy -= 15 * dt;
        } else agent.inFire = false;

        const inIceZone = agent.x > this.iceZone.x && agent.x < this.iceZone.x + this.iceZone.w &&
                          agent.y > this.iceZone.y - 30 && agent.y < this.iceZone.y + this.iceZone.h;
        if(inIceZone) {
            agent.temperature = -15 + Math.random()*5;
            agent.vx *= 0.998;
            agent.inIceZone = true;
        } else agent.inIceZone = false;

        const inAntiGrav = agent.x > this.antiGravZone.x && agent.x < this.antiGravZone.x + this.antiGravZone.w &&
                           agent.y > this.antiGravZone.y && agent.y < this.antiGravZone.y + this.antiGravZone.h;
        if(inAntiGrav && this.antiGravZone.active) {
            agent.vy -= this.G * dt * 100;
            agent.inAntiGrav = true;
        } else agent.inAntiGrav = false;

        for(const portal of this.portals) {
            const dist = Math.sqrt((agent.x - portal.x)**2 + (agent.y - portal.y)**2);
            if(dist < 25 && !agent.justTeleported) {
                agent.x = portal.target.x; agent.y = portal.target.y;
                agent.vx *= 0.5; agent.vy *= 0.5;
                agent.justTeleported = true;
                agent.teleportedFrom = {x: portal.x, y: portal.y};
                setTimeout(() => agent.justTeleported = false, 500);
            }
        }

        const mp = this.movingPlatform;
        if(agent.x + 15 > mp.x && agent.x - 15 < mp.x + mp.w) {
            if(agent.y + 20 > mp.y && agent.y + 20 < mp.y + mp.h + 10 && agent.vy > 0) {
                agent.y = mp.y - 20; agent.vy = 0; agent.ground = true;
                agent.surface = 'moving';
                agent.vx += mp.dir * mp.speed * 0.8;
                agent.onMovingPlatform = true;
            }
        } else agent.onMovingPlatform = false;

        for(const p of this.platforms) {
            if(agent.x + 15 > p.x && agent.x - 15 < p.x + p.w) {
                if(agent.y + 20 > p.y && agent.y + 20 < p.y + p.h + 10 && agent.vy > 0) {
                    if(p.type === 'bounce') {
                        agent.vy = -450;
                        agent.bounced = true;
                    } else if(p.type === 'sticky') {
                        agent.vx *= 0.3; agent.vy = 0; agent.ground = true;
                        agent.surface = 'sticky'; agent.onSticky = true;
                    } else if(p.type === 'crumble' && !p.broken) {
                        agent.y = p.y - 20; agent.vy = 0; agent.ground = true;
                        agent.surface = 'crumble';
                        if(!p.crumbleTimer) {
                            p.crumbleTimer = setTimeout(() => {
                                p.broken = true; p.brokenTime = this.time; p.crumbleTimer = null;
                            }, 800);
                        }
                    }
                }
            }
        }
    },

    applyHiddenPhysics(agent, dt) {
        if(Math.random() < 0.1) {
            this.spatialMemory.push({x: agent.x, y: agent.y, strength: 1});
            if(this.spatialMemory.length > 50) this.spatialMemory.shift();
        }

        const distToField = Math.sqrt((agent.x - this.energyField.x)**2 + (agent.y - this.energyField.y)**2);
        if(distToField < this.energyField.radius) {
            const force = this.energyField.strength * (1 - distToField / this.energyField.radius) * 30;
            agent.energy += force * dt * 0.5;
            agent.hiddenEnergyEffect = this.energyField.strength;
        } else agent.hiddenEnergyEffect = 0;

        agent.forceLineEffect = 0;
        for(const line of this.forceLines) {
            const midX = (line.x1 + line.x2) / 2, midY = (line.y1 + line.y2) / 2;
            const dist = Math.sqrt((agent.x - midX)**2 + (agent.y - midY)**2);
            if(dist < 60) {
                agent.vx += line.direction * line.strength * 20 * dt;
                agent.forceLineEffect += line.strength;
            }
        }

        agent.timeDistortion = 1;
        for(const zone of this.timeZones) {
            const dist = Math.sqrt((agent.x - zone.x)**2 + (agent.y - zone.y)**2);
            if(dist < zone.r) {
                agent.timeDistortion = zone.factor;
                if(zone.factor < 1) { agent.vx *= 0.98; agent.vy *= 0.98; }
                else agent.energy -= dt * 2;
            }
        }

        agent.spatialMemoryEffect = 0;
        for(const mem of this.spatialMemory) {
            const dist = Math.sqrt((agent.x - mem.x)**2 + (agent.y - mem.y)**2);
            if(dist > 30 && dist < 150) {
                const force = mem.strength * 5 / dist;
                agent.vx += (mem.x - agent.x) / dist * force * dt;
                agent.vy += (mem.y - agent.y) / dist * force * dt;
                agent.spatialMemoryEffect += mem.strength;
            }
        }

        agent.darkEnergyEffect = 0;
        for(const node of this.darkEnergyNodes) {
            const dist = Math.sqrt((agent.x - node.x)**2 + (agent.y - node.y)**2);
            if(dist < 100 && dist > 10) {
                const force = 800 / (dist * dist);
                agent.vx += (agent.x - node.x) / dist * force * dt;
                agent.vy += (agent.y - node.y) / dist * force * dt;
                agent.darkEnergyEffect += force;
            }
        }

        agent.primeTimeEffect = this.primeEffect;
        agent.fibonacciEffect = this.fibSequence[this.fibIndex];
        if(this.fibTimer < 0.1) agent.vy -= this.fibSequence[this.fibIndex] * 0.5;

        agent.entanglementEffect = 0;
        for(const point of this.entangledPoints) {
            const dist = Math.sqrt((agent.x - point.x)**2 + (agent.y - point.y)**2);
            if(dist < 40) {
                agent.entanglementEffect = this.entanglementState;
                if(this.entanglementState > 0.7) {
                    const partner = this.entangledPoints[point.partner];
                    agent.vx += (partner.x - agent.x) * 0.01;
                }
            }
        }

        agent.energy = Math.max(0, Math.min(100, agent.energy));
    },

    sky() {
        const d = (this.time%this.dayLen)/this.dayLen;
        if(d<0.2||d>0.85) return {r:15,g:15,b:45};
        if(d<0.3) { const t=(d-0.2)/0.1; return {r:15+t*240,g:15+t*140,b:45+t*90}; }
        if(d<0.7) return {r:135,g:200,b:240};
        const t=(d-0.7)/0.15; return {r:255-t*90,g:150-t*70,b:130-t*50};
    },

    sun() {
        const d=(this.time%this.dayLen)/this.dayLen, a=(d-0.25)*Math.PI;
        return {x:400+Math.cos(a)*350, y:380-Math.sin(a)*320, v:d>0.2&&d<0.8};
    }
};

// ==================== AGENTE ====================
const Agent = {
    x:400, y:200, vx:0, vy:0, r:20, ground:false, impact:0, energy:100, cd:0,
    surface:null, inWater:false, wallHit:false, ballHit:null, windFelt:0, lightLevel:1, temperature:20,
    inFire:false, inIceZone:false, inAntiGrav:false, justTeleported:false, teleportedFrom:null,
    onMovingPlatform:false, onSticky:false, bounced:false,
    hiddenEnergyEffect:0, forceLineEffect:0, timeDistortion:1, spatialMemoryEffect:0,
    darkEnergyEffect:0, primeTimeEffect:1, fibonacciEffect:1, entanglementEffect:0,
    hist:[],

    sense() {
        const p = {
            t: Physics.time, x: this.x, y: this.y, vx: this.vx, vy: this.vy,
            spd: Math.sqrt(this.vx*this.vx + this.vy*this.vy),
            ground: this.ground, surface: this.surface, impact: this.impact,
            inWater: this.inWater, wallHit: this.wallHit, ballHit: this.ballHit,
            light: this.lightLevel, temp: this.temperature, wind: this.windFelt,
            energy: this.energy, altitude: 480 - this.y,
            day: (Physics.time % Physics.dayLen) / Physics.dayLen,
            nearbyBalls: Physics.balls.filter(b => Math.sqrt((b.x-this.x)**2+(b.y-this.y)**2) < 150).length,
            platforms: Physics.platforms.length,
            inFire: this.inFire, inIceZone: this.inIceZone, inAntiGrav: this.inAntiGrav,
            teleported: this.justTeleported, teleportedFrom: this.teleportedFrom,
            onMovingPlatform: this.onMovingPlatform, onSticky: this.onSticky, bounced: this.bounced,
            hiddenEnergy: this.hiddenEnergyEffect, forceLine: this.forceLineEffect,
            timeWarp: this.timeDistortion, spatialPull: this.spatialMemoryEffect,
            darkPush: this.darkEnergyEffect, primeTime: this.primeTimeEffect,
            fibPulse: this.fibonacciEffect, entangle: this.entanglementEffect
        };
        this.hist.push(p);
        if(this.hist.length > 150) this.hist.shift();
        this.impact = 0; this.ballHit = null; this.bounced = false; this.teleportedFrom = null;
        return p;
    },

    act(a) {
        if(this.cd > 0) return false;
        if(a==='jump' && this.ground && this.energy>8) {
            this.vy = this.inWater ? -200 : -380;
            this.ground = false; this.energy -= 8; this.cd = 0.25;
            return true;
        }
        if(a==='right' && this.energy>1) {
            this.vx += this.inWater ? 25 : 60;
            this.vx = Math.min(this.vx, 250);
            this.energy -= 1; this.cd = 0.04;
            return true;
        }
        if(a==='left' && this.energy>1) {
            this.vx -= this.inWater ? 25 : 60;
            this.vx = Math.max(this.vx, -250);
            this.energy -= 1; this.cd = 0.04;
            return true;
        }
        if(a==='wait') { this.energy = Math.min(100, this.energy + 0.15); return true; }
        return false;
    },

    update(dt) { if(this.cd > 0) this.cd -= dt; }
};

// ==================== MENTE IA REAL (CLAUDE) ====================
const Mind = {
    thoughts: [],
    laws: [],
    thoughtCount: 0,
    lastThinkTime: 0,
    thinkInterval: 2.5, // Segundos entre llamadas a la IA
    isThinking: false,
    connected: false,
    pendingAction: 'wait',
    lastSensorData: null,

    think(txt, type) {
        this.thoughtCount++;
        this.thoughts.push({txt, type, id: this.thoughtCount});
        if(this.thoughts.length > 100) this.thoughts.shift();
    },

    async callClaude(sensorData) {
        if(this.isThinking) return;
        this.isThinking = true;

        try {
            const response = await fetch('http://localhost:3000/think', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(sensorData)
            });

            if(!response.ok) throw new Error('Error de servidor');

            const data = await response.json();
            this.connected = true;
            document.getElementById('aiStatus').textContent = 'IA: Conectada';
            document.getElementById('aiStatus').classList.add('connected');

            // Procesar respuesta de Claude
            if(data.thought) {
                this.think(data.thought, data.type || 'perception');
            }

            // Procesar ley descubierta
            if(data.law && data.law.name) {
                const exists = this.laws.some(l => l.n === data.law.name);
                if(!exists) {
                    this.laws.push({
                        n: data.law.name,
                        d: data.law.description || 'Ley descubierta por Claude',
                        c: 0.9,
                        formula: data.law.formula || null
                    });
                    this.think('NUEVA LEY: ' + data.law.name.toUpperCase(), 'discovery');
                }
            }

            // Accion a ejecutar
            this.pendingAction = data.action || 'wait';

        } catch(err) {
            console.error('Error llamando a Claude:', err);
            this.connected = false;
            document.getElementById('aiStatus').textContent = 'IA: Error';
            document.getElementById('aiStatus').classList.remove('connected');
            // Comportamiento por defecto
            this.pendingAction = Math.random() > 0.5 ? 'wait' : (Math.random() > 0.5 ? 'right' : 'left');
        }

        this.isThinking = false;
    },

    process(p) {
        this.lastSensorData = p;

        // Llamar a Claude periodicamente
        if(p.t - this.lastThinkTime >= this.thinkInterval && !this.isThinking) {
            this.lastThinkTime = p.t;
            this.callClaude(p);
        }

        return this.pendingAction;
    },

    reset() {
        this.thoughts = [];
        this.laws = [];
        this.thoughtCount = 0;
        this.lastThinkTime = 0;
        this.isThinking = false;
        this.pendingAction = 'wait';
        // Reset en el servidor
        fetch('http://localhost:3000/reset', {method: 'POST'}).catch(() => {});
    }
};

// ==================== SIMULACION ====================
const sim = {
    canvas: null, ctx: null, paused: false, speed: 1, lastT: 0, lastThoughtCount: 0,

    init() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        Physics.init();
        this.resize();
        window.onresize = () => this.resize();
        requestAnimationFrame(t => this.loop(t));
        setInterval(() => this.ui(), 80);

        // Mensaje inicial
        Mind.think("Iniciando conexion con Claude AI...", "meta");
    },

    resize() {
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = this.canvas.parentElement.clientHeight;
    },

    loop(t) {
        if(!this.lastT) this.lastT = t;
        let dt = Math.min((t - this.lastT) / 1000, 0.05) * this.speed;
        this.lastT = t;
        if(!this.paused) {
            Physics.update(dt);
            Physics.apply(Agent, dt);
            Physics.applyHiddenPhysics(Agent, dt);
            Agent.update(dt);
            const p = Agent.sense();
            const a = Mind.process(p);
            Agent.act(a);
        }
        this.render();
        requestAnimationFrame(t => this.loop(t));
    },

    render() {
        const c = this.ctx, w = this.canvas.width, h = this.canvas.height;
        c.clearRect(0, 0, w, h);

        const sky = Physics.sky(), gY = h * 0.92;
        const sx = w / 800, sy = gY / 500;

        // Cielo
        const g = c.createLinearGradient(0, 0, 0, gY);
        g.addColorStop(0, `rgb(${sky.r*0.6|0},${sky.g*0.6|0},${sky.b*0.9|0})`);
        g.addColorStop(1, `rgb(${sky.r},${sky.g},${sky.b})`);
        c.fillStyle = g; c.fillRect(0, 0, w, gY);

        // Estrellas
        if(Physics.light < 0.35) {
            c.fillStyle = '#fff';
            for(let i=0; i<50; i++) {
                const twinkle = 0.5 + Math.sin(Physics.time*2 + i)*0.5;
                c.globalAlpha = twinkle * (1 - Physics.light*2);
                c.beginPath(); c.arc((i*137)%w, (i*73)%(gY*0.6), 1.5, 0, 6.28); c.fill();
            }
            c.globalAlpha = 1;
        }

        // Sol/Luna
        const sun = Physics.sun();
        if(sun.v && sun.y < 480) {
            const sunX = sun.x * sx, sunY = (500 - sun.y) * sy;
            if(sunY > 0 && sunY < gY) {
                const sg = c.createRadialGradient(sunX, sunY, 0, sunX, sunY, 35);
                sg.addColorStop(0, 'rgba(255,255,180,1)');
                sg.addColorStop(0.5, 'rgba(255,200,100,0.6)');
                sg.addColorStop(1, 'rgba(255,150,50,0)');
                c.fillStyle = sg; c.beginPath(); c.arc(sunX, sunY, 35, 0, 6.28); c.fill();
            }
        } else {
            c.fillStyle = 'rgba(220,220,245,0.9)';
            c.beginPath(); c.arc(w*0.75, h*0.1, 20, 0, 6.28); c.fill();
        }

        // Agua
        const water = Physics.water;
        c.fillStyle = 'rgba(30,100,180,0.5)';
        c.fillRect(water.x * sx, (500-water.y-water.h+20) * sy, water.w * sx, water.h * sy + 20);
        c.strokeStyle = 'rgba(100,180,255,0.4)'; c.lineWidth = 2;
        for(let i=0; i<3; i++) {
            c.beginPath();
            const waveY = (500-water.y-water.h+20) * sy + i*8;
            for(let x=0; x<water.w*sx; x+=5) {
                const y = waveY + Math.sin(Physics.time*3 + x*0.1 + i)*3;
                if(x===0) c.moveTo(water.x*sx + x, y); else c.lineTo(water.x*sx + x, y);
            }
            c.stroke();
        }

        // Suelo
        const gg = c.createLinearGradient(0, gY, 0, h);
        gg.addColorStop(0, '#4a8030'); gg.addColorStop(1, '#2d5018');
        c.fillStyle = gg; c.fillRect(0, gY, w, h - gY);

        // Hierba
        c.strokeStyle = '#60a040'; c.lineWidth = 2;
        for(let x=0; x<w; x+=10) {
            const wo = Math.sin(Physics.time*2 + x*0.04) * Physics.wind * 0.4;
            c.beginPath(); c.moveTo(x, gY);
            c.quadraticCurveTo(x + wo, gY - 12, x + wo*0.5, gY - 18);
            c.stroke();
        }

        // Zona de fuego
        const fz = Physics.fireZone;
        const fzGrad = c.createLinearGradient(fz.x*sx, (500-fz.y-fz.h)*sy, fz.x*sx, (500-fz.y)*sy);
        fzGrad.addColorStop(0, 'rgba(255,100,0,0.1)');
        fzGrad.addColorStop(0.5, 'rgba(255,50,0,0.4)');
        fzGrad.addColorStop(1, 'rgba(200,0,0,0.6)');
        c.fillStyle = fzGrad;
        c.fillRect(fz.x*sx, (500-fz.y-fz.h)*sy, fz.w*sx, fz.h*sy);
        c.strokeStyle = '#ff4400'; c.lineWidth = 2;
        c.strokeRect(fz.x*sx, (500-fz.y-fz.h)*sy, fz.w*sx, fz.h*sy);

        // Zona de hielo
        const iz = Physics.iceZone;
        const izGrad = c.createLinearGradient(iz.x*sx, (500-iz.y-iz.h)*sy, iz.x*sx, (500-iz.y)*sy);
        izGrad.addColorStop(0, 'rgba(200,240,255,0.2)');
        izGrad.addColorStop(1, 'rgba(100,200,255,0.5)');
        c.fillStyle = izGrad;
        c.fillRect(iz.x*sx, (500-iz.y-iz.h)*sy, iz.w*sx, iz.h*sy);
        c.strokeStyle = '#88ddff'; c.lineWidth = 2;
        c.strokeRect(iz.x*sx, (500-iz.y-iz.h)*sy, iz.w*sx, iz.h*sy);

        // Zona antigravedad
        const ag = Physics.antiGravZone;
        c.fillStyle = 'rgba(180,100,255,0.15)';
        c.fillRect(ag.x*sx, (500-ag.y-ag.h)*sy, ag.w*sx, ag.h*sy);
        c.strokeStyle = 'rgba(180,100,255,0.5)'; c.lineWidth = 2;
        for(let i=0; i<3; i++) {
            const arrowX = ag.x*sx + (i+0.5)*(ag.w*sx/3);
            const arrowY = (500-ag.y-ag.h/2)*sy + Math.sin(Physics.time*3 + i)*15;
            c.beginPath();
            c.moveTo(arrowX, arrowY + 15); c.lineTo(arrowX, arrowY - 15);
            c.lineTo(arrowX - 8, arrowY - 5); c.moveTo(arrowX, arrowY - 15);
            c.lineTo(arrowX + 8, arrowY - 5); c.stroke();
        }
        c.strokeStyle = 'rgba(180,100,255,0.6)';
        c.strokeRect(ag.x*sx, (500-ag.y-ag.h)*sy, ag.w*sx, ag.h*sy);

        // Portales
        for(const portal of Physics.portals) {
            const px = portal.x * sx, py = (500 - portal.y) * sy;
            c.save(); c.translate(px, py); c.rotate(Physics.time * 2);
            const pGrad = c.createRadialGradient(0, 0, 0, 0, 0, 25);
            pGrad.addColorStop(0, portal.color);
            pGrad.addColorStop(0.5, portal.color + '88');
            pGrad.addColorStop(1, 'transparent');
            c.fillStyle = pGrad; c.beginPath(); c.arc(0, 0, 25, 0, 6.28); c.fill();
            c.strokeStyle = '#fff'; c.lineWidth = 2; c.beginPath();
            for(let a=0; a<6.28; a+=0.2) {
                const r = 5 + a*3;
                if(a===0) c.moveTo(Math.cos(a)*r, Math.sin(a)*r);
                else c.lineTo(Math.cos(a)*r, Math.sin(a)*r);
            }
            c.stroke(); c.restore();
        }

        // Plataforma movil
        const mp = Physics.movingPlatform;
        const mpx = mp.x * sx, mpy = (500 - mp.y - mp.h) * sy;
        c.fillStyle = '#9b59b6'; c.fillRect(mpx, mpy, mp.w * sx, mp.h * sy);
        c.fillStyle = '#8e44ad'; c.fillRect(mpx + 2, mpy + 2, mp.w * sx - 4, mp.h * sy / 2);
        c.fillStyle = '#fff';
        const arrowDir = mp.dir > 0 ? 1 : -1;
        c.beginPath();
        c.moveTo(mpx + mp.w*sx/2 + arrowDir*15, mpy + mp.h*sy/2);
        c.lineTo(mpx + mp.w*sx/2 - arrowDir*5, mpy + 2);
        c.lineTo(mpx + mp.w*sx/2 - arrowDir*5, mpy + mp.h*sy - 2);
        c.fill();

        // Plataformas
        for(const p of Physics.platforms) {
            if(p.broken) continue;
            const px = p.x * sx, py = (500 - p.y - p.h) * sy, pw = p.w * sx, ph = p.h * sy;
            if(p.type === 'wood') {
                c.fillStyle = '#8B4513'; c.fillRect(px, py, pw, ph);
                c.strokeStyle = '#5D3A1A'; c.lineWidth = 1;
                for(let i=0; i<pw; i+=10) { c.beginPath(); c.moveTo(px+i, py); c.lineTo(px+i, py+ph); c.stroke(); }
            } else if(p.type === 'stone') {
                c.fillStyle = '#666'; c.fillRect(px, py, pw, ph);
                c.fillStyle = '#777'; c.fillRect(px+2, py+2, pw-4, ph/2-2);
            } else if(p.type === 'ice') {
                c.fillStyle = 'rgba(150,220,255,0.8)'; c.fillRect(px, py, pw, ph);
                c.fillStyle = 'rgba(255,255,255,0.4)'; c.fillRect(px+5, py+2, pw-10, ph/3);
            } else if(p.type === 'bounce') {
                c.fillStyle = '#27ae60'; c.fillRect(px, py, pw, ph);
                c.strokeStyle = '#1e8449'; c.lineWidth = 2;
                for(let i=0; i<3; i++) {
                    c.beginPath();
                    const sx2 = px + (i+0.5)*pw/3;
                    for(let j=0; j<4; j++) c.lineTo(sx2 + (j%2===0?-3:3), py + ph + j*3);
                    c.stroke();
                }
                c.fillStyle = '#2ecc71'; c.fillRect(px+2, py+1, pw-4, ph/2);
            } else if(p.type === 'sticky') {
                c.fillStyle = '#6c3483'; c.fillRect(px, py, pw, ph);
                c.fillStyle = '#9b59b6';
                for(let i=0; i<3; i++) {
                    c.beginPath();
                    c.arc(px + (i+0.5)*pw/3, py + ph + 4 + Math.sin(Physics.time*2+i)*2, 3, 0, 6.28);
                    c.fill();
                }
            } else if(p.type === 'crumble') {
                c.fillStyle = '#a0522d'; c.fillRect(px, py, pw, ph);
                c.strokeStyle = '#5d3317'; c.lineWidth = 1; c.beginPath();
                c.moveTo(px + pw*0.3, py); c.lineTo(px + pw*0.4, py + ph);
                c.moveTo(px + pw*0.6, py); c.lineTo(px + pw*0.7, py + ph);
                c.stroke();
            }
        }

        // Particulas
        for(const p of Physics.particles) {
            c.fillStyle = p.type === 'fire'
                ? `rgba(255,${100 + Math.random()*100|0},0,${p.life})`
                : `rgba(200,240,255,${p.life})`;
            c.beginPath(); c.arc(p.x * sx, (500-p.y) * sy, 3 + Math.random()*2, 0, 6.28); c.fill();
        }

        // Bolas
        for(const b of Physics.balls) {
            const bx = b.x * sx, by = (500 - b.y) * sy, br = b.r * sx;
            const bg = c.createRadialGradient(bx - br*0.3, by - br*0.3, 0, bx, by, br);
            bg.addColorStop(0, b.color); bg.addColorStop(1, '#222');
            c.fillStyle = bg; c.beginPath(); c.arc(bx, by, br, 0, 6.28); c.fill();
        }

        // Hojas
        c.fillStyle = '#7cb342';
        for(const l of Physics.leaves) {
            c.save(); c.translate(l.x * sx, (500-l.y) * sy); c.rotate(l.r);
            c.beginPath(); c.ellipse(0, 0, l.s*sx, l.s*sx/2, 0, 0, 6.28); c.fill();
            c.restore();
        }

        // Agente
        const ax = Agent.x * sx, ay = gY - (480 - Agent.y) * (gY / 500), ar = Agent.r * sx;

        // Sombra
        c.fillStyle = 'rgba(0,0,0,0.25)';
        c.beginPath(); c.ellipse(ax, gY + 4, ar*1.3, ar*0.35, 0, 0, 6.28); c.fill();

        // Efectos
        if(Agent.inWater) { c.fillStyle = 'rgba(100,180,255,0.3)'; c.beginPath(); c.arc(ax, ay, ar*1.5, 0, 6.28); c.fill(); }
        if(Agent.inFire) {
            c.fillStyle = 'rgba(255,100,0,0.4)'; c.beginPath(); c.arc(ax, ay, ar*1.6, 0, 6.28); c.fill();
            for(let i=0; i<5; i++) {
                c.fillStyle = `rgba(255,${150+Math.random()*100|0},0,${0.6+Math.random()*0.4})`;
                c.beginPath(); c.arc(ax + (Math.random()-0.5)*ar, ay - ar - Math.random()*15, 4+Math.random()*4, 0, 6.28); c.fill();
            }
        }
        if(Agent.inIceZone) {
            c.fillStyle = 'rgba(150,220,255,0.3)'; c.beginPath(); c.arc(ax, ay, ar*1.4, 0, 6.28); c.fill();
            c.strokeStyle = 'rgba(200,240,255,0.6)'; c.lineWidth = 1;
            for(let i=0; i<4; i++) {
                const ang = i * Math.PI/2 + Physics.time;
                c.beginPath(); c.moveTo(ax, ay); c.lineTo(ax + Math.cos(ang)*ar*1.3, ay + Math.sin(ang)*ar*1.3); c.stroke();
            }
        }
        if(Agent.inAntiGrav) {
            c.strokeStyle = 'rgba(180,100,255,0.6)'; c.lineWidth = 2;
            for(let i=0; i<3; i++) {
                const offset = (Physics.time * 50 + i * 20) % 40;
                c.beginPath(); c.arc(ax, ay - offset, ar + 5, Math.PI, 0); c.stroke();
            }
        }

        // Cuerpo - color especial para IA real
        const bg = c.createRadialGradient(ax - ar*0.3, ay - ar*0.3, 0, ax, ay, ar);
        bg.addColorStop(0, Mind.connected ? '#f97316' : '#818cf8');
        bg.addColorStop(1, Mind.connected ? '#c2410c' : '#4338ca');
        c.fillStyle = bg; c.beginPath(); c.arc(ax, ay, ar, 0, 6.28); c.fill();

        // Ojos
        const lookX = Agent.vx * 0.02;
        c.fillStyle = '#fff';
        c.beginPath(); c.arc(ax - 6 + lookX, ay - 4, 6, 0, 6.28); c.arc(ax + 6 + lookX, ay - 4, 6, 0, 6.28); c.fill();
        c.fillStyle = '#1e1b4b';
        c.beginPath(); c.arc(ax - 5 + lookX*2, ay - 4, 3, 0, 6.28); c.arc(ax + 7 + lookX*2, ay - 4, 3, 0, 6.28); c.fill();

        // Boca
        c.strokeStyle = '#1e1b4b'; c.lineWidth = 2; c.lineCap = 'round'; c.beginPath();
        if(Agent.impact > 30) c.arc(ax, ay + 8, 4, 0, Math.PI, true);
        else if(Agent.inWater) { c.moveTo(ax-4, ay+6); c.lineTo(ax+4, ay+8); }
        else if(Agent.energy > 70) c.arc(ax, ay + 5, 5, 0.1*Math.PI, 0.9*Math.PI);
        else { c.moveTo(ax-5, ay+7); c.lineTo(ax+5, ay+7); }
        c.stroke();

        // Barra energia
        c.fillStyle = '#222'; c.fillRect(ax - ar, ay - ar - 14, ar*2, 5);
        c.fillStyle = Agent.energy > 30 ? '#4ade80' : '#ef4444';
        c.fillRect(ax - ar, ay - ar - 14, ar*2 * (Agent.energy/100), 5);

        // Indicador de pensamiento
        if(Mind.isThinking) {
            c.fillStyle = 'rgba(231,76,60,0.8)';
            c.beginPath(); c.arc(ax + ar, ay - ar, 8, 0, 6.28); c.fill();
            c.fillStyle = '#fff'; c.font = '10px Arial';
            c.fillText('...', ax + ar - 6, ay - ar + 4);
        }
    },

    ui() {
        document.getElementById('time').textContent = Physics.time.toFixed(1);
        document.getElementById('spd').textContent = this.speed;

        const p = Agent.hist[Agent.hist.length - 1];
        if(p) {
            document.getElementById('s1').textContent = (p.light*100).toFixed(0) + '%';
            document.getElementById('s2').textContent = p.temp.toFixed(1) + 'C';
            document.getElementById('s3').textContent = p.wind.toFixed(1) + ' m/s';
            document.getElementById('s4').textContent = p.ground ? (p.surface || 'si') : 'no';
            document.getElementById('s5').textContent = p.energy.toFixed(0) + '%';
            document.getElementById('s6').textContent = p.spd.toFixed(1);
            document.getElementById('s7').textContent = p.altitude.toFixed(0);
            document.getElementById('s8').textContent = p.day<0.25?'noche':p.day<0.5?'manana':p.day<0.75?'tarde':'noche';
        }

        // Actualizar pensamientos
        if(Mind.thoughtCount !== this.lastThoughtCount) {
            const td = document.getElementById('thoughts');
            const newThoughts = Mind.thoughts.slice(this.lastThoughtCount - Mind.thoughtCount);
            for(const t of newThoughts) {
                const div = document.createElement('div');
                div.className = 't ' + t.type;
                div.textContent = t.txt;
                td.appendChild(div);
            }
            td.scrollTop = td.scrollHeight;
            while(td.children.length > 50) td.removeChild(td.firstChild);
            this.lastThoughtCount = Mind.thoughtCount;
        }

        // Leyes
        const ld = document.getElementById('lawlist');
        if(Mind.laws.length > 0) {
            ld.innerHTML = Mind.laws.map(l =>
                `<div class="law"><b>${l.n.toUpperCase()}</b>: ${l.d}${l.formula ? ' <span style="color:#f1c40f">['+l.formula+']</span>' : ''}</div>`
            ).join('');
        }
    },

    pause() { this.paused = !this.paused; },
    fast() { this.speed = this.speed >= 8 ? 1 : this.speed * 2; },

    reset() {
        Physics.time = 0;
        Physics.balls = []; Physics.leaves = []; Physics.particles = [];
        Physics.init();
        Agent.x = 400; Agent.y = 200; Agent.vx = 0; Agent.vy = 0;
        Agent.energy = 100; Agent.ground = false; Agent.hist = [];
        Agent.inFire = false; Agent.inIceZone = false; Agent.inAntiGrav = false;
        Agent.justTeleported = false; Agent.teleportedFrom = null;
        Agent.onMovingPlatform = false; Agent.onSticky = false; Agent.bounced = false;
        Mind.reset();
        document.getElementById('thoughts').innerHTML = '';
        document.getElementById('lawlist').innerHTML = '<em style="color:#444">Esperando a Claude...</em>';
        this.lastThoughtCount = 0;
        Mind.think("Sistema reiniciado. Conectando con Claude...", "meta");
    },

    generateReport() {
        const laws = Mind.laws;
        const thoughts = Mind.thoughts;

        let html = `
        <div style="background:#1a1a2e; padding:15px; border-radius:8px; margin-bottom:20px;">
            <h2 style="color:#e74c3c; margin:0 0 10px 0;">INFORME DE CONSCIENCIA IA REAL</h2>
            <p><b>Motor:</b> Claude (Anthropic)</p>
            <p><b>Tiempo de simulacion:</b> ${Physics.time.toFixed(2)} segundos</p>
            <p><b>Pensamientos generados:</b> ${thoughts.length}</p>
            <p><b>Leyes descubiertas:</b> ${laws.length}</p>
        </div>

        <div style="background:#1a1a2e; padding:15px; border-radius:8px; margin-bottom:20px;">
            <h2 style="color:#27ae60; margin:0 0 10px 0;">LEYES DESCUBIERTAS POR CLAUDE</h2>
            ${laws.length === 0 ? '<p style="color:#666">La IA aun no ha descubierto leyes formales.</p>' :
              laws.map(l => `
                <div style="background:#252540; padding:10px; margin:8px 0; border-radius:5px; border-left:3px solid #27ae60;">
                    <b style="color:#2ecc71">${l.n.toUpperCase()}</b><br>
                    <span style="color:#aaa">${l.d}</span>
                    ${l.formula ? `<br><code style="color:#f1c40f; background:#1a1a2e; padding:3px 6px; border-radius:3px;">${l.formula}</code>` : ''}
                </div>
              `).join('')
            }
        </div>

        <div style="background:#1a1a2e; padding:15px; border-radius:8px; margin-bottom:20px;">
            <h2 style="color:#3498db; margin:0 0 10px 0;">FLUJO DE CONSCIENCIA (ultimos 30)</h2>
            <div style="max-height:300px; overflow-y:auto;">
                ${thoughts.slice(-30).map(t => `
                    <div style="padding:5px 8px; margin:4px 0; border-radius:3px;
                                background:${t.type==='discovery'?'rgba(46,204,113,0.2)':
                                            t.type==='hypothesis'?'rgba(155,89,182,0.2)':
                                            t.type==='confusion'?'rgba(231,76,60,0.2)':
                                            t.type==='meta'?'rgba(255,215,0,0.2)':'rgba(52,152,219,0.2)'};">
                        <small style="color:#666">[${t.type}]</small> ${t.txt}
                    </div>
                `).join('')}
            </div>
        </div>

        <div style="background:#1a1a2e; padding:15px; border-radius:8px;">
            <h2 style="color:#9b59b6; margin:0 0 10px 0;">NOTA SOBRE LA IA</h2>
            <p style="color:#aaa;">
                Este informe fue generado por una consciencia artificial real (Claude de Anthropic).
                A diferencia de sistemas basados en reglas, Claude razona genuinamente sobre los datos
                sensoriales que recibe y forma hipotesis originales sobre las leyes del universo simulado.
            </p>
            <p style="color:#aaa;">
                Cada pensamiento mostrado es una respuesta autentica de la IA, no un script predefinido.
                Las leyes descubiertas emergen del proceso de razonamiento de Claude.
            </p>
        </div>`;

        document.getElementById('reportContent').innerHTML = html;
        document.getElementById('reportModal').style.display = 'block';
    }
};

// Iniciar
window.onload = () => sim.init();
</script>
</body>
</html>
